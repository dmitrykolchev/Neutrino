import{Encoder as e,Decoder as t}from"/lib/msgpack/msgpack.js";import{MessageType as r,TransferFormat as n,NullLogger as s,LogLevel as o}from"signalr.js";const a="5.0.0-dev";class i{static write(e){let t=e.byteLength||e.length;const r=[];do{let e=127&t;t>>=7,t>0&&(e|=128),r.push(e)}while(t>0);t=e.byteLength||e.length;const n=new Uint8Array(r.length+t);return n.set(r,0),n.set(e,r.length),n.buffer}static parse(e){const t=[],r=new Uint8Array(e),n=[0,7,14,21,28];for(let s=0;s<e.byteLength;){let o,a=0,i=0;do{o=r[s+a],i|=(127&o)<<n[a],a++}while(a<Math.min(5,e.byteLength-s)&&128&o);if(128&o&&a<5)throw new Error("Cannot read message size.");if(5===a&&o>7)throw new Error("Messages bigger than 2GB are not supported.");if(!(r.byteLength>=s+a+i))throw new Error("Incomplete message.");t.push(r.slice?r.slice(s+a,s+a+i):r.subarray(s+a,s+a+i)),s=s+a+i}return t}}const c=new Uint8Array([145,r.Ping]);class d{constructor(r){this.name="messagepack",this.version=2,this.transferFormat=n.Binary,this._errorResult=1,this._voidResult=2,this._nonVoidResult=3,r=r||{},this._encoder=new e(r.extensionCodec,r.context,r.maxDepth,r.initialBufferSize,r.sortKeys,r.forceFloat32,r.ignoreUndefined,r.forceIntegerToFloat),this._decoder=new t(r.extensionCodec,r.context,r.maxStrLength,r.maxBinLength,r.maxArrayLength,r.maxMapLength,r.maxExtLength)}parseMessages(e,t){if(!(r=e)||"undefined"==typeof ArrayBuffer||!(r instanceof ArrayBuffer||r.constructor&&"ArrayBuffer"===r.constructor.name))throw new Error("Invalid input for MessagePack hub protocol. Expected an ArrayBuffer.");var r;null===t&&(t=s.instance);const n=i.parse(e),o=[];for(const e of n){const r=this._parseMessage(e,t);r&&o.push(r)}return o}writeMessage(e){switch(e.type){case r.Invocation:return this._writeInvocation(e);case r.StreamInvocation:return this._writeStreamInvocation(e);case r.StreamItem:return this._writeStreamItem(e);case r.Completion:return this._writeCompletion(e);case r.Ping:return i.write(c);case r.CancelInvocation:return this._writeCancelInvocation(e);case r.Close:return this._writeClose();case r.Ack:return this._writeAck(e);case r.Sequence:return this._writeSequence(e);default:throw new Error("Invalid message type.")}}_parseMessage(e,t){if(0===e.length)throw new Error("Invalid payload.");const n=this._decoder.decode(e);if(0===n.length||!(n instanceof Array))throw new Error("Invalid payload.");const s=n[0];switch(s){case r.Invocation:return this._createInvocationMessage(this._readHeaders(n),n);case r.StreamItem:return this._createStreamItemMessage(this._readHeaders(n),n);case r.Completion:return this._createCompletionMessage(this._readHeaders(n),n);case r.Ping:return this._createPingMessage(n);case r.Close:return this._createCloseMessage(n);case r.Ack:return this._createAckMessage(n);case r.Sequence:return this._createSequenceMessage(n);default:return t.log(o.Information,"Unknown message type '"+s+"' ignored."),null}}_createCloseMessage(e){if(e.length<2)throw new Error("Invalid payload for Close message.");return{allowReconnect:e.length>=3?e[2]:void 0,error:e[1],type:r.Close}}_createPingMessage(e){if(e.length<1)throw new Error("Invalid payload for Ping message.");return{type:r.Ping}}_createInvocationMessage(e,t){if(t.length<5)throw new Error("Invalid payload for Invocation message.");const n=t[2];return n?{arguments:t[4],headers:e,invocationId:n,streamIds:[],target:t[3],type:r.Invocation}:{arguments:t[4],headers:e,streamIds:[],target:t[3],type:r.Invocation}}_createStreamItemMessage(e,t){if(t.length<4)throw new Error("Invalid payload for StreamItem message.");return{headers:e,invocationId:t[2],item:t[3],type:r.StreamItem}}_createCompletionMessage(e,t){if(t.length<4)throw new Error("Invalid payload for Completion message.");const n=t[3];if(n!==this._voidResult&&t.length<5)throw new Error("Invalid payload for Completion message.");let s,o;switch(n){case this._errorResult:s=t[4];break;case this._nonVoidResult:o=t[4]}return{error:s,headers:e,invocationId:t[2],result:o,type:r.Completion}}_createAckMessage(e){if(e.length<1)throw new Error("Invalid payload for Ack message.");return{sequenceId:e[1],type:r.Ack}}_createSequenceMessage(e){if(e.length<1)throw new Error("Invalid payload for Sequence message.");return{sequenceId:e[1],type:r.Sequence}}_writeInvocation(e){let t;return t=e.streamIds?this._encoder.encode([r.Invocation,e.headers||{},e.invocationId||null,e.target,e.arguments,e.streamIds]):this._encoder.encode([r.Invocation,e.headers||{},e.invocationId||null,e.target,e.arguments]),i.write(t.slice())}_writeStreamInvocation(e){let t;return t=e.streamIds?this._encoder.encode([r.StreamInvocation,e.headers||{},e.invocationId,e.target,e.arguments,e.streamIds]):this._encoder.encode([r.StreamInvocation,e.headers||{},e.invocationId,e.target,e.arguments]),i.write(t.slice())}_writeStreamItem(e){const t=this._encoder.encode([r.StreamItem,e.headers||{},e.invocationId,e.item]);return i.write(t.slice())}_writeCompletion(e){const t=e.error?this._errorResult:void 0!==e.result?this._nonVoidResult:this._voidResult;let n;switch(t){case this._errorResult:n=this._encoder.encode([r.Completion,e.headers||{},e.invocationId,t,e.error]);break;case this._voidResult:n=this._encoder.encode([r.Completion,e.headers||{},e.invocationId,t]);break;case this._nonVoidResult:n=this._encoder.encode([r.Completion,e.headers||{},e.invocationId,t,e.result])}return i.write(n.slice())}_writeCancelInvocation(e){const t=this._encoder.encode([r.CancelInvocation,e.headers||{},e.invocationId]);return i.write(t.slice())}_writeClose(){const e=this._encoder.encode([r.Close,null]);return i.write(e.slice())}_writeAck(e){const t=this._encoder.encode([r.Ack,e.sequenceId]);return i.write(t.slice())}_writeSequence(e){const t=this._encoder.encode([r.Sequence,e.sequenceId]);return i.write(t.slice())}_readHeaders(e){const t=e[1];if("object"!=typeof t)throw new Error("Invalid headers.");return t}}export{d as MessagePackHubProtocol,a as VERSION};
//# sourceMappingURL=signalr-protocol-msgpack.min.js.map
