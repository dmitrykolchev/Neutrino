{"version":3,"file":"msgpack.min.js","sources":["../../src/utils/utf8.ts","../../src/ExtData.ts","../../src/DecodeError.ts","../../src/utils/int.ts","../../src/timestamp.ts","../../src/ExtensionCodec.ts","../../src/utils/typedArrays.ts","../../src/Encoder.ts","../../src/encode.ts","../../src/utils/prettyByte.ts","../../src/Decoder.ts","../../src/CachedKeyDecoder.ts","../../src/decode.ts","../../src/utils/stream.ts","../../src/decodeAsync.ts"],"sourcesContent":["export function utf8Count(str: string): number {\r\n  const strLength = str.length;\r\n\r\n  let byteLength = 0;\r\n  let pos = 0;\r\n  while (pos < strLength) {\r\n    let value = str.charCodeAt(pos++);\r\n\r\n    if ((value & 0xffffff80) === 0) {\r\n      // 1-byte\r\n      byteLength++;\r\n      continue;\r\n    } else if ((value & 0xfffff800) === 0) {\r\n      // 2-bytes\r\n      byteLength += 2;\r\n    } else {\r\n      // handle surrogate pair\r\n      if (value >= 0xd800 && value <= 0xdbff) {\r\n        // high surrogate\r\n        if (pos < strLength) {\r\n          const extra = str.charCodeAt(pos);\r\n          if ((extra & 0xfc00) === 0xdc00) {\r\n            ++pos;\r\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\r\n          }\r\n        }\r\n      }\r\n\r\n      if ((value & 0xffff0000) === 0) {\r\n        // 3-byte\r\n        byteLength += 3;\r\n      } else {\r\n        // 4-byte\r\n        byteLength += 4;\r\n      }\r\n    }\r\n  }\r\n  return byteLength;\r\n}\r\n\r\nexport function utf8EncodeJs(str: string, output: Uint8Array, outputOffset: number): void {\r\n  const strLength = str.length;\r\n  let offset = outputOffset;\r\n  let pos = 0;\r\n  while (pos < strLength) {\r\n    let value = str.charCodeAt(pos++);\r\n\r\n    if ((value & 0xffffff80) === 0) {\r\n      // 1-byte\r\n      output[offset++] = value;\r\n      continue;\r\n    } else if ((value & 0xfffff800) === 0) {\r\n      // 2-bytes\r\n      output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\r\n    } else {\r\n      // handle surrogate pair\r\n      if (value >= 0xd800 && value <= 0xdbff) {\r\n        // high surrogate\r\n        if (pos < strLength) {\r\n          const extra = str.charCodeAt(pos);\r\n          if ((extra & 0xfc00) === 0xdc00) {\r\n            ++pos;\r\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\r\n          }\r\n        }\r\n      }\r\n\r\n      if ((value & 0xffff0000) === 0) {\r\n        // 3-byte\r\n        output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\r\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\r\n      } else {\r\n        // 4-byte\r\n        output[offset++] = ((value >> 18) & 0x07) | 0xf0;\r\n        output[offset++] = ((value >> 12) & 0x3f) | 0x80;\r\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\r\n      }\r\n    }\r\n\r\n    output[offset++] = (value & 0x3f) | 0x80;\r\n  }\r\n}\r\n\r\n// TextEncoder and TextDecoder are standardized in whatwg encoding:\r\n// https://encoding.spec.whatwg.org/\r\n// and available in all the modern browsers:\r\n// https://caniuse.com/textencoder\r\n// They are available in Node.js since v12 LTS as well:\r\n// https://nodejs.org/api/globals.html#textencoder\r\n\r\nconst sharedTextEncoder = new TextEncoder();\r\n\r\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\r\n// Run `npx ts-node benchmark/encode-string.ts` for details.\r\nconst TEXT_ENCODER_THRESHOLD = 50;\r\n\r\nexport function utf8EncodeTE(str: string, output: Uint8Array, outputOffset: number): void {\r\n  sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\r\n}\r\n\r\nexport function utf8Encode(str: string, output: Uint8Array, outputOffset: number): void {\r\n  if (str.length > TEXT_ENCODER_THRESHOLD) {\r\n    utf8EncodeTE(str, output, outputOffset);\r\n  } else {\r\n    utf8EncodeJs(str, output, outputOffset);\r\n  }\r\n}\r\n\r\nconst CHUNK_SIZE = 0x1_000;\r\n\r\nexport function utf8DecodeJs(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\r\n  let offset = inputOffset;\r\n  const end = offset + byteLength;\r\n\r\n  const units: Array<number> = [];\r\n  let result = \"\";\r\n  while (offset < end) {\r\n    const byte1 = bytes[offset++]!;\r\n    if ((byte1 & 0x80) === 0) {\r\n      // 1 byte\r\n      units.push(byte1);\r\n    } else if ((byte1 & 0xe0) === 0xc0) {\r\n      // 2 bytes\r\n      const byte2 = bytes[offset++]! & 0x3f;\r\n      units.push(((byte1 & 0x1f) << 6) | byte2);\r\n    } else if ((byte1 & 0xf0) === 0xe0) {\r\n      // 3 bytes\r\n      const byte2 = bytes[offset++]! & 0x3f;\r\n      const byte3 = bytes[offset++]! & 0x3f;\r\n      units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\r\n    } else if ((byte1 & 0xf8) === 0xf0) {\r\n      // 4 bytes\r\n      const byte2 = bytes[offset++]! & 0x3f;\r\n      const byte3 = bytes[offset++]! & 0x3f;\r\n      const byte4 = bytes[offset++]! & 0x3f;\r\n      let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\r\n      if (unit > 0xffff) {\r\n        unit -= 0x10000;\r\n        units.push(((unit >>> 10) & 0x3ff) | 0xd800);\r\n        unit = 0xdc00 | (unit & 0x3ff);\r\n      }\r\n      units.push(unit);\r\n    } else {\r\n      units.push(byte1);\r\n    }\r\n\r\n    if (units.length >= CHUNK_SIZE) {\r\n      result += String.fromCharCode(...units);\r\n      units.length = 0;\r\n    }\r\n  }\r\n\r\n  if (units.length > 0) {\r\n    result += String.fromCharCode(...units);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nconst sharedTextDecoder = new TextDecoder();\r\n\r\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\r\n// Run `npx ts-node benchmark/decode-string.ts` for details.\r\nconst TEXT_DECODER_THRESHOLD = 200;\r\n\r\nexport function utf8DecodeTD(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\r\n  const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\r\n  return sharedTextDecoder.decode(stringBytes);\r\n}\r\n\r\nexport function utf8Decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\r\n  if (byteLength > TEXT_DECODER_THRESHOLD) {\r\n    return utf8DecodeTD(bytes, inputOffset, byteLength);\r\n  } else {\r\n    return utf8DecodeJs(bytes, inputOffset, byteLength);\r\n  }\r\n}\r\n","/**\r\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\r\n */\r\nexport class ExtData {\r\n  constructor(\r\n    readonly type: number,\r\n    readonly data: Uint8Array,\r\n  ) {}\r\n}\r\n","export class DecodeError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n\r\n    // fix the prototype chain in a cross-platform way\r\n    const proto: typeof DecodeError.prototype = Object.create(DecodeError.prototype);\r\n    Object.setPrototypeOf(this, proto);\r\n\r\n    Object.defineProperty(this, \"name\", {\r\n      configurable: true,\r\n      enumerable: false,\r\n      value: DecodeError.name,\r\n    });\r\n  }\r\n}\r\n","// Integer Utility\r\n\r\nexport const UINT32_MAX = 0xffff_ffff;\r\n\r\n// DataView extension to handle int64 / uint64,\r\n// where the actual range is 53-bits integer (a.k.a. safe integer)\r\n\r\nexport function setUint64(view: DataView, offset: number, value: number): void {\r\n  const high = value / 0x1_0000_0000;\r\n  const low = value; // high bits are truncated by DataView\r\n  view.setUint32(offset, high);\r\n  view.setUint32(offset + 4, low);\r\n}\r\n\r\nexport function setInt64(view: DataView, offset: number, value: number): void {\r\n  const high = Math.floor(value / 0x1_0000_0000);\r\n  const low = value; // high bits are truncated by DataView\r\n  view.setUint32(offset, high);\r\n  view.setUint32(offset + 4, low);\r\n}\r\n\r\nexport function getInt64(view: DataView, offset: number): number {\r\n  const high = view.getInt32(offset);\r\n  const low = view.getUint32(offset + 4);\r\n  return high * 0x1_0000_0000 + low;\r\n}\r\n\r\nexport function getUint64(view: DataView, offset: number): number {\r\n  const high = view.getUint32(offset);\r\n  const low = view.getUint32(offset + 4);\r\n  return high * 0x1_0000_0000 + low;\r\n}\r\n","// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\r\nimport { DecodeError } from \"./DecodeError\";\r\nimport { getInt64, setInt64 } from \"./utils/int\";\r\n\r\nexport const EXT_TIMESTAMP = -1;\r\n\r\nexport type TimeSpec = {\r\n  sec: number;\r\n  nsec: number;\r\n};\r\n\r\nconst TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\r\nconst TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\r\n\r\nexport function encodeTimeSpecToTimestamp({ sec, nsec }: TimeSpec): Uint8Array {\r\n  if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\r\n    // Here sec >= 0 && nsec >= 0\r\n    if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\r\n      // timestamp 32 = { sec32 (unsigned) }\r\n      const rv = new Uint8Array(4);\r\n      const view = new DataView(rv.buffer);\r\n      view.setUint32(0, sec);\r\n      return rv;\r\n    } else {\r\n      // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\r\n      const secHigh = sec / 0x100000000;\r\n      const secLow = sec & 0xffffffff;\r\n      const rv = new Uint8Array(8);\r\n      const view = new DataView(rv.buffer);\r\n      // nsec30 | secHigh2\r\n      view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\r\n      // secLow32\r\n      view.setUint32(4, secLow);\r\n      return rv;\r\n    }\r\n  } else {\r\n    // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\r\n    const rv = new Uint8Array(12);\r\n    const view = new DataView(rv.buffer);\r\n    view.setUint32(0, nsec);\r\n    setInt64(view, 4, sec);\r\n    return rv;\r\n  }\r\n}\r\n\r\nexport function encodeDateToTimeSpec(date: Date): TimeSpec {\r\n  const msec = date.getTime();\r\n  const sec = Math.floor(msec / 1e3);\r\n  const nsec = (msec - sec * 1e3) * 1e6;\r\n\r\n  // Normalizes { sec, nsec } to ensure nsec is unsigned.\r\n  const nsecInSec = Math.floor(nsec / 1e9);\r\n  return {\r\n    sec: sec + nsecInSec,\r\n    nsec: nsec - nsecInSec * 1e9,\r\n  };\r\n}\r\n\r\nexport function encodeTimestampExtension(object: unknown): Uint8Array | null {\r\n  if (object instanceof Date) {\r\n    const timeSpec = encodeDateToTimeSpec(object);\r\n    return encodeTimeSpecToTimestamp(timeSpec);\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport function decodeTimestampToTimeSpec(data: Uint8Array): TimeSpec {\r\n  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n\r\n  // data may be 32, 64, or 96 bits\r\n  switch (data.byteLength) {\r\n    case 4: {\r\n      // timestamp 32 = { sec32 }\r\n      const sec = view.getUint32(0);\r\n      const nsec = 0;\r\n      return { sec, nsec };\r\n    }\r\n    case 8: {\r\n      // timestamp 64 = { nsec30, sec34 }\r\n      const nsec30AndSecHigh2 = view.getUint32(0);\r\n      const secLow32 = view.getUint32(4);\r\n      const sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\r\n      const nsec = nsec30AndSecHigh2 >>> 2;\r\n      return { sec, nsec };\r\n    }\r\n    case 12: {\r\n      // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\r\n\r\n      const sec = getInt64(view, 4);\r\n      const nsec = view.getUint32(0);\r\n      return { sec, nsec };\r\n    }\r\n    default:\r\n      throw new DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);\r\n  }\r\n}\r\n\r\nexport function decodeTimestampExtension(data: Uint8Array): Date {\r\n  const timeSpec = decodeTimestampToTimeSpec(data);\r\n  return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\r\n}\r\n\r\nexport const timestampExtension = {\r\n  type: EXT_TIMESTAMP,\r\n  encode: encodeTimestampExtension,\r\n  decode: decodeTimestampExtension,\r\n};\r\n","// ExtensionCodec to handle MessagePack extensions\r\n\r\nimport { ExtData } from \"./ExtData\";\r\nimport { timestampExtension } from \"./timestamp\";\r\n\r\nexport type ExtensionDecoderType<ContextType> = (\r\n  data: Uint8Array,\r\n  extensionType: number,\r\n  context: ContextType,\r\n) => unknown;\r\n\r\nexport type ExtensionEncoderType<ContextType> = (input: unknown, context: ContextType) => Uint8Array | null;\r\n\r\n// immutable interface to ExtensionCodec\r\nexport type ExtensionCodecType<ContextType> = {\r\n  // eslint-disable-next-line @typescript-eslint/naming-convention\r\n  __brand?: ContextType;\r\n  tryToEncode(object: unknown, context: ContextType): ExtData | null;\r\n  decode(data: Uint8Array, extType: number, context: ContextType): unknown;\r\n};\r\n\r\nexport class ExtensionCodec<ContextType = undefined> implements ExtensionCodecType<ContextType> {\r\n  public static readonly defaultCodec: ExtensionCodecType<undefined> = new ExtensionCodec();\r\n\r\n  // ensures ExtensionCodecType<X> matches ExtensionCodec<X>\r\n  // this will make type errors a lot more clear\r\n  // eslint-disable-next-line @typescript-eslint/naming-convention\r\n  __brand?: ContextType;\r\n\r\n  // built-in extensions\r\n  private readonly builtInEncoders: Array<ExtensionEncoderType<ContextType> | undefined | null> = [];\r\n  private readonly builtInDecoders: Array<ExtensionDecoderType<ContextType> | undefined | null> = [];\r\n\r\n  // custom extensions\r\n  private readonly encoders: Array<ExtensionEncoderType<ContextType> | undefined | null> = [];\r\n  private readonly decoders: Array<ExtensionDecoderType<ContextType> | undefined | null> = [];\r\n\r\n  public constructor() {\r\n    this.register(timestampExtension);\r\n  }\r\n\r\n  public register({\r\n    type,\r\n    encode,\r\n    decode,\r\n  }: {\r\n    type: number;\r\n    encode: ExtensionEncoderType<ContextType>;\r\n    decode: ExtensionDecoderType<ContextType>;\r\n  }): void {\r\n    if (type >= 0) {\r\n      // custom extensions\r\n      this.encoders[type] = encode;\r\n      this.decoders[type] = decode;\r\n    } else {\r\n      // built-in extensions\r\n      const index = 1 + type;\r\n      this.builtInEncoders[index] = encode;\r\n      this.builtInDecoders[index] = decode;\r\n    }\r\n  }\r\n\r\n  public tryToEncode(object: unknown, context: ContextType): ExtData | null {\r\n    // built-in extensions\r\n    for (let i = 0; i < this.builtInEncoders.length; i++) {\r\n      const encodeExt = this.builtInEncoders[i];\r\n      if (encodeExt != null) {\r\n        const data = encodeExt(object, context);\r\n        if (data != null) {\r\n          const type = -1 - i;\r\n          return new ExtData(type, data);\r\n        }\r\n      }\r\n    }\r\n\r\n    // custom extensions\r\n    for (let i = 0; i < this.encoders.length; i++) {\r\n      const encodeExt = this.encoders[i];\r\n      if (encodeExt != null) {\r\n        const data = encodeExt(object, context);\r\n        if (data != null) {\r\n          const type = i;\r\n          return new ExtData(type, data);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (object instanceof ExtData) {\r\n      // to keep ExtData as is\r\n      return object;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  public decode(data: Uint8Array, type: number, context: ContextType): unknown {\r\n    const decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\r\n    if (decodeExt) {\r\n      return decodeExt(data, type, context);\r\n    } else {\r\n      // decode() does not fail, returns ExtData instead.\r\n      return new ExtData(type, data);\r\n    }\r\n  }\r\n}\r\n","export function ensureUint8Array(buffer: ArrayLike<number> | Uint8Array | ArrayBufferView | ArrayBuffer): Uint8Array {\r\n  if (buffer instanceof Uint8Array) {\r\n    return buffer;\r\n  } else if (ArrayBuffer.isView(buffer)) {\r\n    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\r\n  } else if (buffer instanceof ArrayBuffer) {\r\n    return new Uint8Array(buffer);\r\n  } else {\r\n    // ArrayLike<number>\r\n    return Uint8Array.from(buffer);\r\n  }\r\n}\r\n\r\nexport function createDataView(buffer: ArrayLike<number> | ArrayBufferView | ArrayBuffer): DataView {\r\n  if (buffer instanceof ArrayBuffer) {\r\n    return new DataView(buffer);\r\n  }\r\n\r\n  const bufferView = ensureUint8Array(buffer);\r\n  return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\r\n}\r\n","import { utf8Count, utf8Encode } from \"./utils/utf8\";\r\nimport { ExtensionCodec, ExtensionCodecType } from \"./ExtensionCodec\";\r\nimport { setInt64, setUint64 } from \"./utils/int\";\r\nimport { ensureUint8Array } from \"./utils/typedArrays\";\r\nimport type { ExtData } from \"./ExtData\";\r\nimport type { ContextOf } from \"./context\";\r\n\r\nexport const DEFAULT_MAX_DEPTH = 100;\r\nexport const DEFAULT_INITIAL_BUFFER_SIZE = 2048;\r\n\r\nexport type EncoderOptions<ContextType = undefined> = Partial<\r\n  Readonly<{\r\n    extensionCodec: ExtensionCodecType<ContextType>;\r\n\r\n    /**\r\n     * Encodes bigint as Int64 or Uint64 if it's set to true.\r\n     * {@link forceIntegerToFloat} does not affect bigint.\r\n     * Depends on ES2020's {@link DataView#setBigInt64} and\r\n     * {@link DataView#setBigUint64}.\r\n     *\r\n     * Defaults to false.\r\n     */\r\n    useBigInt64: boolean;\r\n\r\n    /**\r\n     * The maximum depth in nested objects and arrays.\r\n     *\r\n     * Defaults to 100.\r\n     */\r\n    maxDepth: number;\r\n\r\n    /**\r\n     * The initial size of the internal buffer.\r\n     *\r\n     * Defaults to 2048.\r\n     */\r\n    initialBufferSize: number;\r\n\r\n    /**\r\n     * If `true`, the keys of an object is sorted. In other words, the encoded\r\n     * binary is canonical and thus comparable to another encoded binary.\r\n     *\r\n     * Defaults to `false`. If enabled, it spends more time in encoding objects.\r\n     */\r\n    sortKeys: boolean;\r\n    /**\r\n     * If `true`, non-integer numbers are encoded in float32, not in float64 (the default).\r\n     *\r\n     * Only use it if precisions don't matter.\r\n     *\r\n     * Defaults to `false`.\r\n     */\r\n    forceFloat32: boolean;\r\n\r\n    /**\r\n     * If `true`, an object property with `undefined` value are ignored.\r\n     * e.g. `{ foo: undefined }` will be encoded as `{}`, as `JSON.stringify()` does.\r\n     *\r\n     * Defaults to `false`. If enabled, it spends more time in encoding objects.\r\n     */\r\n    ignoreUndefined: boolean;\r\n\r\n    /**\r\n     * If `true`, integer numbers are encoded as floating point numbers,\r\n     * with the `forceFloat32` option taken into account.\r\n     *\r\n     * Defaults to `false`.\r\n     */\r\n    forceIntegerToFloat: boolean;\r\n  }>\r\n> &\r\n  ContextOf<ContextType>;\r\n\r\nexport class Encoder<ContextType = undefined> {\r\n  private readonly extensionCodec: ExtensionCodecType<ContextType>;\r\n  private readonly context: ContextType;\r\n  private readonly useBigInt64: boolean;\r\n  private readonly maxDepth: number;\r\n  private readonly initialBufferSize: number;\r\n  private readonly sortKeys: boolean;\r\n  private readonly forceFloat32: boolean;\r\n  private readonly ignoreUndefined: boolean;\r\n  private readonly forceIntegerToFloat: boolean;\r\n\r\n  private pos: number;\r\n  private view: DataView;\r\n  private bytes: Uint8Array;\r\n\r\n  public constructor(options?: EncoderOptions<ContextType>) {\r\n    this.extensionCodec = options?.extensionCodec ?? (ExtensionCodec.defaultCodec as ExtensionCodecType<ContextType>);\r\n    this.context = (options as { context: ContextType } | undefined)?.context as ContextType; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\r\n\r\n    this.useBigInt64 = options?.useBigInt64 ?? false;\r\n    this.maxDepth = options?.maxDepth ?? DEFAULT_MAX_DEPTH;\r\n    this.initialBufferSize = options?.initialBufferSize ?? DEFAULT_INITIAL_BUFFER_SIZE;\r\n    this.sortKeys = options?.sortKeys ?? false;\r\n    this.forceFloat32 = options?.forceFloat32 ?? false;\r\n    this.ignoreUndefined = options?.ignoreUndefined ?? false;\r\n    this.forceIntegerToFloat = options?.forceIntegerToFloat ?? false;\r\n\r\n    this.pos = 0;\r\n    this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\r\n    this.bytes = new Uint8Array(this.view.buffer);\r\n  }\r\n\r\n  private reinitializeState() {\r\n    this.pos = 0;\r\n  }\r\n\r\n  /**\r\n   * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.\r\n   *\r\n   * @returns Encodes the object and returns a shared reference the encoder's internal buffer.\r\n   */\r\n  public encodeSharedRef(object: unknown): Uint8Array {\r\n    this.reinitializeState();\r\n    this.doEncode(object, 1);\r\n    return this.bytes.subarray(0, this.pos);\r\n  }\r\n\r\n  /**\r\n   * @returns Encodes the object and returns a copy of the encoder's internal buffer.\r\n   */\r\n  public encode(object: unknown): Uint8Array {\r\n    this.reinitializeState();\r\n    this.doEncode(object, 1);\r\n    return this.bytes.slice(0, this.pos);\r\n  }\r\n\r\n  private doEncode(object: unknown, depth: number): void {\r\n    if (depth > this.maxDepth) {\r\n      throw new Error(`Too deep objects in depth ${depth}`);\r\n    }\r\n\r\n    if (object == null) {\r\n      this.encodeNil();\r\n    } else if (typeof object === \"boolean\") {\r\n      this.encodeBoolean(object);\r\n    } else if (typeof object === \"number\") {\r\n      if (!this.forceIntegerToFloat) {\r\n        this.encodeNumber(object);\r\n      } else {\r\n        this.encodeNumberAsFloat(object);\r\n      }\r\n    } else if (typeof object === \"string\") {\r\n      this.encodeString(object);\r\n    } else if (this.useBigInt64 && typeof object === \"bigint\") {\r\n      this.encodeBigInt64(object);\r\n    } else {\r\n      this.encodeObject(object, depth);\r\n    }\r\n  }\r\n\r\n  private ensureBufferSizeToWrite(sizeToWrite: number) {\r\n    const requiredSize = this.pos + sizeToWrite;\r\n\r\n    if (this.view.byteLength < requiredSize) {\r\n      this.resizeBuffer(requiredSize * 2);\r\n    }\r\n  }\r\n\r\n  private resizeBuffer(newSize: number) {\r\n    const newBuffer = new ArrayBuffer(newSize);\r\n    const newBytes = new Uint8Array(newBuffer);\r\n    const newView = new DataView(newBuffer);\r\n\r\n    newBytes.set(this.bytes);\r\n\r\n    this.view = newView;\r\n    this.bytes = newBytes;\r\n  }\r\n\r\n  private encodeNil() {\r\n    this.writeU8(0xc0);\r\n  }\r\n\r\n  private encodeBoolean(object: boolean) {\r\n    if (object === false) {\r\n      this.writeU8(0xc2);\r\n    } else {\r\n      this.writeU8(0xc3);\r\n    }\r\n  }\r\n\r\n  private encodeNumber(object: number): void {\r\n    if (!this.forceIntegerToFloat && Number.isSafeInteger(object)) {\r\n      if (object >= 0) {\r\n        if (object < 0x80) {\r\n          // positive fixint\r\n          this.writeU8(object);\r\n        } else if (object < 0x100) {\r\n          // uint 8\r\n          this.writeU8(0xcc);\r\n          this.writeU8(object);\r\n        } else if (object < 0x10000) {\r\n          // uint 16\r\n          this.writeU8(0xcd);\r\n          this.writeU16(object);\r\n        } else if (object < 0x100000000) {\r\n          // uint 32\r\n          this.writeU8(0xce);\r\n          this.writeU32(object);\r\n        } else if (!this.useBigInt64) {\r\n          // uint 64\r\n          this.writeU8(0xcf);\r\n          this.writeU64(object);\r\n        } else {\r\n          this.encodeNumberAsFloat(object);\r\n        }\r\n      } else {\r\n        if (object >= -0x20) {\r\n          // negative fixint\r\n          this.writeU8(0xe0 | (object + 0x20));\r\n        } else if (object >= -0x80) {\r\n          // int 8\r\n          this.writeU8(0xd0);\r\n          this.writeI8(object);\r\n        } else if (object >= -0x8000) {\r\n          // int 16\r\n          this.writeU8(0xd1);\r\n          this.writeI16(object);\r\n        } else if (object >= -0x80000000) {\r\n          // int 32\r\n          this.writeU8(0xd2);\r\n          this.writeI32(object);\r\n        } else if (!this.useBigInt64) {\r\n          // int 64\r\n          this.writeU8(0xd3);\r\n          this.writeI64(object);\r\n        } else {\r\n          this.encodeNumberAsFloat(object);\r\n        }\r\n      }\r\n    } else {\r\n      this.encodeNumberAsFloat(object);\r\n    }\r\n  }\r\n\r\n  private encodeNumberAsFloat(object: number): void {\r\n    if (this.forceFloat32) {\r\n      // float 32\r\n      this.writeU8(0xca);\r\n      this.writeF32(object);\r\n    } else {\r\n      // float 64\r\n      this.writeU8(0xcb);\r\n      this.writeF64(object);\r\n    }\r\n  }\r\n\r\n  private encodeBigInt64(object: bigint): void {\r\n    if (object >= BigInt(0)) {\r\n      // uint 64\r\n      this.writeU8(0xcf);\r\n      this.writeBigUint64(object);\r\n    } else {\r\n      // int 64\r\n      this.writeU8(0xd3);\r\n      this.writeBigInt64(object);\r\n    }\r\n  }\r\n\r\n  private writeStringHeader(byteLength: number) {\r\n    if (byteLength < 32) {\r\n      // fixstr\r\n      this.writeU8(0xa0 + byteLength);\r\n    } else if (byteLength < 0x100) {\r\n      // str 8\r\n      this.writeU8(0xd9);\r\n      this.writeU8(byteLength);\r\n    } else if (byteLength < 0x10000) {\r\n      // str 16\r\n      this.writeU8(0xda);\r\n      this.writeU16(byteLength);\r\n    } else if (byteLength < 0x100000000) {\r\n      // str 32\r\n      this.writeU8(0xdb);\r\n      this.writeU32(byteLength);\r\n    } else {\r\n      throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);\r\n    }\r\n  }\r\n\r\n  private encodeString(object: string) {\r\n    const maxHeaderSize = 1 + 4;\r\n\r\n    const byteLength = utf8Count(object);\r\n    this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\r\n    this.writeStringHeader(byteLength);\r\n    utf8Encode(object, this.bytes, this.pos);\r\n    this.pos += byteLength;\r\n  }\r\n\r\n  private encodeObject(object: unknown, depth: number) {\r\n    // try to encode objects with custom codec first of non-primitives\r\n    const ext = this.extensionCodec.tryToEncode(object, this.context);\r\n    if (ext != null) {\r\n      this.encodeExtension(ext);\r\n    } else if (Array.isArray(object)) {\r\n      this.encodeArray(object, depth);\r\n    } else if (ArrayBuffer.isView(object)) {\r\n      this.encodeBinary(object);\r\n    } else if (typeof object === \"object\") {\r\n      this.encodeMap(object as Record<string, unknown>, depth);\r\n    } else {\r\n      // symbol, function and other special object come here unless extensionCodec handles them.\r\n      throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);\r\n    }\r\n  }\r\n\r\n  private encodeBinary(object: ArrayBufferView) {\r\n    const size = object.byteLength;\r\n    if (size < 0x100) {\r\n      // bin 8\r\n      this.writeU8(0xc4);\r\n      this.writeU8(size);\r\n    } else if (size < 0x10000) {\r\n      // bin 16\r\n      this.writeU8(0xc5);\r\n      this.writeU16(size);\r\n    } else if (size < 0x100000000) {\r\n      // bin 32\r\n      this.writeU8(0xc6);\r\n      this.writeU32(size);\r\n    } else {\r\n      throw new Error(`Too large binary: ${size}`);\r\n    }\r\n    const bytes = ensureUint8Array(object);\r\n    this.writeU8a(bytes);\r\n  }\r\n\r\n  private encodeArray(object: Array<unknown>, depth: number) {\r\n    const size = object.length;\r\n    if (size < 16) {\r\n      // fixarray\r\n      this.writeU8(0x90 + size);\r\n    } else if (size < 0x10000) {\r\n      // array 16\r\n      this.writeU8(0xdc);\r\n      this.writeU16(size);\r\n    } else if (size < 0x100000000) {\r\n      // array 32\r\n      this.writeU8(0xdd);\r\n      this.writeU32(size);\r\n    } else {\r\n      throw new Error(`Too large array: ${size}`);\r\n    }\r\n    for (const item of object) {\r\n      this.doEncode(item, depth + 1);\r\n    }\r\n  }\r\n\r\n  private countWithoutUndefined(object: Record<string, unknown>, keys: ReadonlyArray<string>): number {\r\n    let count = 0;\r\n\r\n    for (const key of keys) {\r\n      if (object[key] !== undefined) {\r\n        count++;\r\n      }\r\n    }\r\n\r\n    return count;\r\n  }\r\n\r\n  private encodeMap(object: Record<string, unknown>, depth: number) {\r\n    const keys = Object.keys(object);\r\n    if (this.sortKeys) {\r\n      keys.sort();\r\n    }\r\n\r\n    const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\r\n\r\n    if (size < 16) {\r\n      // fixmap\r\n      this.writeU8(0x80 + size);\r\n    } else if (size < 0x10000) {\r\n      // map 16\r\n      this.writeU8(0xde);\r\n      this.writeU16(size);\r\n    } else if (size < 0x100000000) {\r\n      // map 32\r\n      this.writeU8(0xdf);\r\n      this.writeU32(size);\r\n    } else {\r\n      throw new Error(`Too large map object: ${size}`);\r\n    }\r\n\r\n    for (const key of keys) {\r\n      const value = object[key];\r\n\r\n      if (!(this.ignoreUndefined && value === undefined)) {\r\n        this.encodeString(key);\r\n        this.doEncode(value, depth + 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  private encodeExtension(ext: ExtData) {\r\n    const size = ext.data.length;\r\n    if (size === 1) {\r\n      // fixext 1\r\n      this.writeU8(0xd4);\r\n    } else if (size === 2) {\r\n      // fixext 2\r\n      this.writeU8(0xd5);\r\n    } else if (size === 4) {\r\n      // fixext 4\r\n      this.writeU8(0xd6);\r\n    } else if (size === 8) {\r\n      // fixext 8\r\n      this.writeU8(0xd7);\r\n    } else if (size === 16) {\r\n      // fixext 16\r\n      this.writeU8(0xd8);\r\n    } else if (size < 0x100) {\r\n      // ext 8\r\n      this.writeU8(0xc7);\r\n      this.writeU8(size);\r\n    } else if (size < 0x10000) {\r\n      // ext 16\r\n      this.writeU8(0xc8);\r\n      this.writeU16(size);\r\n    } else if (size < 0x100000000) {\r\n      // ext 32\r\n      this.writeU8(0xc9);\r\n      this.writeU32(size);\r\n    } else {\r\n      throw new Error(`Too large extension object: ${size}`);\r\n    }\r\n    this.writeI8(ext.type);\r\n    this.writeU8a(ext.data);\r\n  }\r\n\r\n  private writeU8(value: number) {\r\n    this.ensureBufferSizeToWrite(1);\r\n\r\n    this.view.setUint8(this.pos, value);\r\n    this.pos++;\r\n  }\r\n\r\n  private writeU8a(values: ArrayLike<number>) {\r\n    const size = values.length;\r\n    this.ensureBufferSizeToWrite(size);\r\n\r\n    this.bytes.set(values, this.pos);\r\n    this.pos += size;\r\n  }\r\n\r\n  private writeI8(value: number) {\r\n    this.ensureBufferSizeToWrite(1);\r\n\r\n    this.view.setInt8(this.pos, value);\r\n    this.pos++;\r\n  }\r\n\r\n  private writeU16(value: number) {\r\n    this.ensureBufferSizeToWrite(2);\r\n\r\n    this.view.setUint16(this.pos, value);\r\n    this.pos += 2;\r\n  }\r\n\r\n  private writeI16(value: number) {\r\n    this.ensureBufferSizeToWrite(2);\r\n\r\n    this.view.setInt16(this.pos, value);\r\n    this.pos += 2;\r\n  }\r\n\r\n  private writeU32(value: number) {\r\n    this.ensureBufferSizeToWrite(4);\r\n\r\n    this.view.setUint32(this.pos, value);\r\n    this.pos += 4;\r\n  }\r\n\r\n  private writeI32(value: number) {\r\n    this.ensureBufferSizeToWrite(4);\r\n\r\n    this.view.setInt32(this.pos, value);\r\n    this.pos += 4;\r\n  }\r\n\r\n  private writeF32(value: number) {\r\n    this.ensureBufferSizeToWrite(4);\r\n\r\n    this.view.setFloat32(this.pos, value);\r\n    this.pos += 4;\r\n  }\r\n\r\n  private writeF64(value: number) {\r\n    this.ensureBufferSizeToWrite(8);\r\n\r\n    this.view.setFloat64(this.pos, value);\r\n    this.pos += 8;\r\n  }\r\n\r\n  private writeU64(value: number) {\r\n    this.ensureBufferSizeToWrite(8);\r\n\r\n    setUint64(this.view, this.pos, value);\r\n    this.pos += 8;\r\n  }\r\n\r\n  private writeI64(value: number) {\r\n    this.ensureBufferSizeToWrite(8);\r\n\r\n    setInt64(this.view, this.pos, value);\r\n    this.pos += 8;\r\n  }\r\n\r\n  private writeBigUint64(value: bigint) {\r\n    this.ensureBufferSizeToWrite(8);\r\n\r\n    this.view.setBigUint64(this.pos, value);\r\n    this.pos += 8;\r\n  }\r\n\r\n  private writeBigInt64(value: bigint) {\r\n    this.ensureBufferSizeToWrite(8);\r\n\r\n    this.view.setBigInt64(this.pos, value);\r\n    this.pos += 8;\r\n  }\r\n}\r\n","import { Encoder } from \"./Encoder\";\r\nimport type { EncoderOptions } from \"./Encoder\";\r\nimport type { SplitUndefined } from \"./context\";\r\n\r\n/**\r\n * @deprecated Use {@link EncoderOptions} instead.\r\n */\r\nexport type EncodeOptions = never;\r\n\r\n/**\r\n * @deprecated No longer supported.\r\n */\r\nexport const defaultEncodeOptions: never = undefined as never;\r\n\r\n/**\r\n * It encodes `value` in the MessagePack format and\r\n * returns a byte buffer.\r\n *\r\n * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.\r\n */\r\nexport function encode<ContextType = undefined>(\r\n  value: unknown,\r\n  options?: EncoderOptions<SplitUndefined<ContextType>>,\r\n): Uint8Array {\r\n  const encoder = new Encoder(options);\r\n  return encoder.encodeSharedRef(value);\r\n}\r\n","export function prettyByte(byte: number): string {\r\n  return `${byte < 0 ? \"-\" : \"\"}0x${Math.abs(byte).toString(16).padStart(2, \"0\")}`;\r\n}\r\n","import { prettyByte } from \"./utils/prettyByte\";\r\nimport { ExtensionCodec, ExtensionCodecType } from \"./ExtensionCodec\";\r\nimport { getInt64, getUint64, UINT32_MAX } from \"./utils/int\";\r\nimport { utf8Decode } from \"./utils/utf8\";\r\nimport { createDataView, ensureUint8Array } from \"./utils/typedArrays\";\r\nimport { CachedKeyDecoder, KeyDecoder } from \"./CachedKeyDecoder\";\r\nimport { DecodeError } from \"./DecodeError\";\r\nimport type { ContextOf } from \"./context\";\r\n\r\nexport type DecoderOptions<ContextType = undefined> = Readonly<\r\n  Partial<{\r\n    extensionCodec: ExtensionCodecType<ContextType>;\r\n\r\n    /**\r\n     * Decodes Int64 and Uint64 as bigint if it's set to true.\r\n     * Depends on ES2020's {@link DataView#getBigInt64} and\r\n     * {@link DataView#getBigUint64}.\r\n     *\r\n     * Defaults to false.\r\n     */\r\n    useBigInt64: boolean;\r\n\r\n    /**\r\n     * Maximum string length.\r\n     *\r\n     * Defaults to 4_294_967_295 (UINT32_MAX).\r\n     */\r\n    maxStrLength: number;\r\n    /**\r\n     * Maximum binary length.\r\n     *\r\n     * Defaults to 4_294_967_295 (UINT32_MAX).\r\n     */\r\n    maxBinLength: number;\r\n    /**\r\n     * Maximum array length.\r\n     *\r\n     * Defaults to 4_294_967_295 (UINT32_MAX).\r\n     */\r\n    maxArrayLength: number;\r\n    /**\r\n     * Maximum map length.\r\n     *\r\n     * Defaults to 4_294_967_295 (UINT32_MAX).\r\n     */\r\n    maxMapLength: number;\r\n    /**\r\n     * Maximum extension length.\r\n     *\r\n     * Defaults to 4_294_967_295 (UINT32_MAX).\r\n     */\r\n    maxExtLength: number;\r\n\r\n    /**\r\n     * An object key decoder. Defaults to the shared instance of {@link CachedKeyDecoder}.\r\n     * `null` is a special value to disable the use of the key decoder at all.\r\n     */\r\n    keyDecoder: KeyDecoder | null;\r\n  }>\r\n> &\r\n  ContextOf<ContextType>;\r\n\r\nconst STATE_ARRAY = \"array\";\r\nconst STATE_MAP_KEY = \"map_key\";\r\nconst STATE_MAP_VALUE = \"map_value\";\r\n\r\ntype MapKeyType = string | number;\r\n\r\nconst isValidMapKeyType = (key: unknown): key is MapKeyType => {\r\n  return typeof key === \"string\" || typeof key === \"number\";\r\n};\r\n\r\ntype StackMapState = {\r\n  type: typeof STATE_MAP_KEY | typeof STATE_MAP_VALUE;\r\n  size: number;\r\n  key: MapKeyType | null;\r\n  readCount: number;\r\n  map: Record<string, unknown>;\r\n};\r\n\r\ntype StackArrayState = {\r\n  type: typeof STATE_ARRAY;\r\n  size: number;\r\n  array: Array<unknown>;\r\n  position: number;\r\n};\r\n\r\nclass StackPool {\r\n  private readonly stack: Array<StackState> = [];\r\n  private stackHeadPosition = -1;\r\n\r\n  public get length(): number {\r\n    return this.stackHeadPosition + 1;\r\n  }\r\n\r\n  public top(): StackState | undefined {\r\n    return this.stack[this.stackHeadPosition];\r\n  }\r\n\r\n  public pushArrayState(size: number) {\r\n    const state = this.getUninitializedStateFromPool() as StackArrayState;\r\n\r\n    state.type = STATE_ARRAY;\r\n    state.position = 0;\r\n    state.size = size;\r\n    state.array = new Array(size);\r\n  }\r\n\r\n  public pushMapState(size: number) {\r\n    const state = this.getUninitializedStateFromPool() as StackMapState;\r\n\r\n    state.type = STATE_MAP_KEY;\r\n    state.readCount = 0;\r\n    state.size = size;\r\n    state.map = {};\r\n  }\r\n\r\n  private getUninitializedStateFromPool() {\r\n    this.stackHeadPosition++;\r\n\r\n    if (this.stackHeadPosition === this.stack.length) {\r\n      const partialState: Partial<StackState> = {\r\n        type: undefined,\r\n        size: 0,\r\n        array: undefined,\r\n        position: 0,\r\n        readCount: 0,\r\n        map: undefined,\r\n        key: null,\r\n      };\r\n\r\n      this.stack.push(partialState as StackState);\r\n    }\r\n\r\n    return this.stack[this.stackHeadPosition];\r\n  }\r\n\r\n  public release(state: StackState): void {\r\n    const topStackState = this.stack[this.stackHeadPosition];\r\n\r\n    if (topStackState !== state) {\r\n      throw new Error(\"Invalid stack state. Released state is not on top of the stack.\");\r\n    }\r\n\r\n    if (state.type === STATE_ARRAY) {\r\n      const partialState = state as Partial<StackArrayState>;\r\n      partialState.size = 0;\r\n      partialState.array = undefined;\r\n      partialState.position = 0;\r\n      partialState.type = undefined;\r\n    }\r\n\r\n    if (state.type === STATE_MAP_KEY || state.type === STATE_MAP_VALUE) {\r\n      const partialState = state as Partial<StackMapState>;\r\n      partialState.size = 0;\r\n      partialState.map = undefined;\r\n      partialState.readCount = 0;\r\n      partialState.type = undefined;\r\n    }\r\n\r\n    this.stackHeadPosition--;\r\n  }\r\n\r\n  public reset(): void {\r\n    this.stack.length = 0;\r\n    this.stackHeadPosition = -1;\r\n  }\r\n}\r\n\r\ntype StackState = StackArrayState | StackMapState;\r\n\r\nconst HEAD_BYTE_REQUIRED = -1;\r\n\r\nconst EMPTY_VIEW = new DataView(new ArrayBuffer(0));\r\nconst EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\r\n\r\ntry {\r\n  // IE11: The spec says it should throw RangeError,\r\n  // IE11: but in IE11 it throws TypeError.\r\n  EMPTY_VIEW.getInt8(0);\r\n} catch (e) {\r\n  if (!(e instanceof RangeError)) {\r\n    throw new Error(\r\n      \"This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access\",\r\n    );\r\n  }\r\n}\r\nexport const DataViewIndexOutOfBoundsError = RangeError;\r\n\r\nconst MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\r\n\r\nconst sharedCachedKeyDecoder = new CachedKeyDecoder();\r\n\r\nexport class Decoder<ContextType = undefined> {\r\n  private readonly extensionCodec: ExtensionCodecType<ContextType>;\r\n  private readonly context: ContextType;\r\n  private readonly useBigInt64: boolean;\r\n  private readonly maxStrLength: number;\r\n  private readonly maxBinLength: number;\r\n  private readonly maxArrayLength: number;\r\n  private readonly maxMapLength: number;\r\n  private readonly maxExtLength: number;\r\n  private readonly keyDecoder: KeyDecoder | null;\r\n\r\n  private totalPos = 0;\r\n  private pos = 0;\r\n\r\n  private view = EMPTY_VIEW;\r\n  private bytes = EMPTY_BYTES;\r\n  private headByte = HEAD_BYTE_REQUIRED;\r\n  private readonly stack = new StackPool();\r\n\r\n  public constructor(options?: DecoderOptions<ContextType>) {\r\n    this.extensionCodec = options?.extensionCodec ?? (ExtensionCodec.defaultCodec as ExtensionCodecType<ContextType>);\r\n    this.context = (options as { context: ContextType } | undefined)?.context as ContextType; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\r\n\r\n    this.useBigInt64 = options?.useBigInt64 ?? false;\r\n    this.maxStrLength = options?.maxStrLength ?? UINT32_MAX;\r\n    this.maxBinLength = options?.maxBinLength ?? UINT32_MAX;\r\n    this.maxArrayLength = options?.maxArrayLength ?? UINT32_MAX;\r\n    this.maxMapLength = options?.maxMapLength ?? UINT32_MAX;\r\n    this.maxExtLength = options?.maxExtLength ?? UINT32_MAX;\r\n    this.keyDecoder = options?.keyDecoder !== undefined ? options.keyDecoder : sharedCachedKeyDecoder;\r\n  }\r\n\r\n  private reinitializeState() {\r\n    this.totalPos = 0;\r\n    this.headByte = HEAD_BYTE_REQUIRED;\r\n    this.stack.reset();\r\n\r\n    // view, bytes, and pos will be re-initialized in setBuffer()\r\n  }\r\n\r\n  private setBuffer(buffer: ArrayLike<number> | BufferSource): void {\r\n    this.bytes = ensureUint8Array(buffer);\r\n    this.view = createDataView(this.bytes);\r\n    this.pos = 0;\r\n  }\r\n\r\n  private appendBuffer(buffer: ArrayLike<number> | BufferSource) {\r\n    if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\r\n      this.setBuffer(buffer);\r\n    } else {\r\n      const remainingData = this.bytes.subarray(this.pos);\r\n      const newData = ensureUint8Array(buffer);\r\n\r\n      // concat remainingData + newData\r\n      const newBuffer = new Uint8Array(remainingData.length + newData.length);\r\n      newBuffer.set(remainingData);\r\n      newBuffer.set(newData, remainingData.length);\r\n      this.setBuffer(newBuffer);\r\n    }\r\n  }\r\n\r\n  private hasRemaining(size: number) {\r\n    return this.view.byteLength - this.pos >= size;\r\n  }\r\n\r\n  private createExtraByteError(posToShow: number): Error {\r\n    const { view, pos } = this;\r\n    return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);\r\n  }\r\n\r\n  /**\r\n   * @throws {@link DecodeError}\r\n   * @throws {@link RangeError}\r\n   */\r\n  public decode(buffer: ArrayLike<number> | BufferSource): unknown {\r\n    this.reinitializeState();\r\n    this.setBuffer(buffer);\r\n\r\n    const object = this.doDecodeSync();\r\n    if (this.hasRemaining(1)) {\r\n      throw this.createExtraByteError(this.pos);\r\n    }\r\n    return object;\r\n  }\r\n\r\n  public *decodeMulti(buffer: ArrayLike<number> | BufferSource): Generator<unknown, void, unknown> {\r\n    this.reinitializeState();\r\n    this.setBuffer(buffer);\r\n\r\n    while (this.hasRemaining(1)) {\r\n      yield this.doDecodeSync();\r\n    }\r\n  }\r\n\r\n  public async decodeAsync(stream: AsyncIterable<ArrayLike<number> | BufferSource>): Promise<unknown> {\r\n    let decoded = false;\r\n    let object: unknown;\r\n    for await (const buffer of stream) {\r\n      if (decoded) {\r\n        throw this.createExtraByteError(this.totalPos);\r\n      }\r\n\r\n      this.appendBuffer(buffer);\r\n\r\n      try {\r\n        object = this.doDecodeSync();\r\n        decoded = true;\r\n      } catch (e) {\r\n        if (!(e instanceof DataViewIndexOutOfBoundsError)) {\r\n          throw e; // rethrow\r\n        }\r\n        // fallthrough\r\n      }\r\n      this.totalPos += this.pos;\r\n    }\r\n\r\n    if (decoded) {\r\n      if (this.hasRemaining(1)) {\r\n        throw this.createExtraByteError(this.totalPos);\r\n      }\r\n      return object;\r\n    }\r\n\r\n    const { headByte, pos, totalPos } = this;\r\n    throw new RangeError(\r\n      `Insufficient data in parsing ${prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`,\r\n    );\r\n  }\r\n\r\n  public decodeArrayStream(\r\n    stream: AsyncIterable<ArrayLike<number> | BufferSource>,\r\n  ): AsyncGenerator<unknown, void, unknown> {\r\n    return this.decodeMultiAsync(stream, true);\r\n  }\r\n\r\n  public decodeStream(stream: AsyncIterable<ArrayLike<number> | BufferSource>): AsyncGenerator<unknown, void, unknown> {\r\n    return this.decodeMultiAsync(stream, false);\r\n  }\r\n\r\n  private async *decodeMultiAsync(stream: AsyncIterable<ArrayLike<number> | BufferSource>, isArray: boolean) {\r\n    let isArrayHeaderRequired = isArray;\r\n    let arrayItemsLeft = -1;\r\n\r\n    for await (const buffer of stream) {\r\n      if (isArray && arrayItemsLeft === 0) {\r\n        throw this.createExtraByteError(this.totalPos);\r\n      }\r\n\r\n      this.appendBuffer(buffer);\r\n\r\n      if (isArrayHeaderRequired) {\r\n        arrayItemsLeft = this.readArraySize();\r\n        isArrayHeaderRequired = false;\r\n        this.complete();\r\n      }\r\n\r\n      try {\r\n        while (true) {\r\n          yield this.doDecodeSync();\r\n          if (--arrayItemsLeft === 0) {\r\n            break;\r\n          }\r\n        }\r\n      } catch (e) {\r\n        if (!(e instanceof DataViewIndexOutOfBoundsError)) {\r\n          throw e; // rethrow\r\n        }\r\n        // fallthrough\r\n      }\r\n      this.totalPos += this.pos;\r\n    }\r\n  }\r\n\r\n  private doDecodeSync(): unknown {\r\n    DECODE: while (true) {\r\n      const headByte = this.readHeadByte();\r\n      let object: unknown;\r\n\r\n      if (headByte >= 0xe0) {\r\n        // negative fixint (111x xxxx) 0xe0 - 0xff\r\n        object = headByte - 0x100;\r\n      } else if (headByte < 0xc0) {\r\n        if (headByte < 0x80) {\r\n          // positive fixint (0xxx xxxx) 0x00 - 0x7f\r\n          object = headByte;\r\n        } else if (headByte < 0x90) {\r\n          // fixmap (1000 xxxx) 0x80 - 0x8f\r\n          const size = headByte - 0x80;\r\n          if (size !== 0) {\r\n            this.pushMapState(size);\r\n            this.complete();\r\n            continue DECODE;\r\n          } else {\r\n            object = {};\r\n          }\r\n        } else if (headByte < 0xa0) {\r\n          // fixarray (1001 xxxx) 0x90 - 0x9f\r\n          const size = headByte - 0x90;\r\n          if (size !== 0) {\r\n            this.pushArrayState(size);\r\n            this.complete();\r\n            continue DECODE;\r\n          } else {\r\n            object = [];\r\n          }\r\n        } else {\r\n          // fixstr (101x xxxx) 0xa0 - 0xbf\r\n          const byteLength = headByte - 0xa0;\r\n          object = this.decodeUtf8String(byteLength, 0);\r\n        }\r\n      } else if (headByte === 0xc0) {\r\n        // nil\r\n        object = null;\r\n      } else if (headByte === 0xc2) {\r\n        // false\r\n        object = false;\r\n      } else if (headByte === 0xc3) {\r\n        // true\r\n        object = true;\r\n      } else if (headByte === 0xca) {\r\n        // float 32\r\n        object = this.readF32();\r\n      } else if (headByte === 0xcb) {\r\n        // float 64\r\n        object = this.readF64();\r\n      } else if (headByte === 0xcc) {\r\n        // uint 8\r\n        object = this.readU8();\r\n      } else if (headByte === 0xcd) {\r\n        // uint 16\r\n        object = this.readU16();\r\n      } else if (headByte === 0xce) {\r\n        // uint 32\r\n        object = this.readU32();\r\n      } else if (headByte === 0xcf) {\r\n        // uint 64\r\n        if (this.useBigInt64) {\r\n          object = this.readU64AsBigInt();\r\n        } else {\r\n          object = this.readU64();\r\n        }\r\n      } else if (headByte === 0xd0) {\r\n        // int 8\r\n        object = this.readI8();\r\n      } else if (headByte === 0xd1) {\r\n        // int 16\r\n        object = this.readI16();\r\n      } else if (headByte === 0xd2) {\r\n        // int 32\r\n        object = this.readI32();\r\n      } else if (headByte === 0xd3) {\r\n        // int 64\r\n        if (this.useBigInt64) {\r\n          object = this.readI64AsBigInt();\r\n        } else {\r\n          object = this.readI64();\r\n        }\r\n      } else if (headByte === 0xd9) {\r\n        // str 8\r\n        const byteLength = this.lookU8();\r\n        object = this.decodeUtf8String(byteLength, 1);\r\n      } else if (headByte === 0xda) {\r\n        // str 16\r\n        const byteLength = this.lookU16();\r\n        object = this.decodeUtf8String(byteLength, 2);\r\n      } else if (headByte === 0xdb) {\r\n        // str 32\r\n        const byteLength = this.lookU32();\r\n        object = this.decodeUtf8String(byteLength, 4);\r\n      } else if (headByte === 0xdc) {\r\n        // array 16\r\n        const size = this.readU16();\r\n        if (size !== 0) {\r\n          this.pushArrayState(size);\r\n          this.complete();\r\n          continue DECODE;\r\n        } else {\r\n          object = [];\r\n        }\r\n      } else if (headByte === 0xdd) {\r\n        // array 32\r\n        const size = this.readU32();\r\n        if (size !== 0) {\r\n          this.pushArrayState(size);\r\n          this.complete();\r\n          continue DECODE;\r\n        } else {\r\n          object = [];\r\n        }\r\n      } else if (headByte === 0xde) {\r\n        // map 16\r\n        const size = this.readU16();\r\n        if (size !== 0) {\r\n          this.pushMapState(size);\r\n          this.complete();\r\n          continue DECODE;\r\n        } else {\r\n          object = {};\r\n        }\r\n      } else if (headByte === 0xdf) {\r\n        // map 32\r\n        const size = this.readU32();\r\n        if (size !== 0) {\r\n          this.pushMapState(size);\r\n          this.complete();\r\n          continue DECODE;\r\n        } else {\r\n          object = {};\r\n        }\r\n      } else if (headByte === 0xc4) {\r\n        // bin 8\r\n        const size = this.lookU8();\r\n        object = this.decodeBinary(size, 1);\r\n      } else if (headByte === 0xc5) {\r\n        // bin 16\r\n        const size = this.lookU16();\r\n        object = this.decodeBinary(size, 2);\r\n      } else if (headByte === 0xc6) {\r\n        // bin 32\r\n        const size = this.lookU32();\r\n        object = this.decodeBinary(size, 4);\r\n      } else if (headByte === 0xd4) {\r\n        // fixext 1\r\n        object = this.decodeExtension(1, 0);\r\n      } else if (headByte === 0xd5) {\r\n        // fixext 2\r\n        object = this.decodeExtension(2, 0);\r\n      } else if (headByte === 0xd6) {\r\n        // fixext 4\r\n        object = this.decodeExtension(4, 0);\r\n      } else if (headByte === 0xd7) {\r\n        // fixext 8\r\n        object = this.decodeExtension(8, 0);\r\n      } else if (headByte === 0xd8) {\r\n        // fixext 16\r\n        object = this.decodeExtension(16, 0);\r\n      } else if (headByte === 0xc7) {\r\n        // ext 8\r\n        const size = this.lookU8();\r\n        object = this.decodeExtension(size, 1);\r\n      } else if (headByte === 0xc8) {\r\n        // ext 16\r\n        const size = this.lookU16();\r\n        object = this.decodeExtension(size, 2);\r\n      } else if (headByte === 0xc9) {\r\n        // ext 32\r\n        const size = this.lookU32();\r\n        object = this.decodeExtension(size, 4);\r\n      } else {\r\n        throw new DecodeError(`Unrecognized type byte: ${prettyByte(headByte)}`);\r\n      }\r\n\r\n      this.complete();\r\n\r\n      const stack = this.stack;\r\n      while (stack.length > 0) {\r\n        // arrays and maps\r\n        const state = stack.top()!;\r\n        if (state.type === STATE_ARRAY) {\r\n          state.array[state.position] = object;\r\n          state.position++;\r\n          if (state.position === state.size) {\r\n            object = state.array;\r\n            stack.release(state);\r\n          } else {\r\n            continue DECODE;\r\n          }\r\n        } else if (state.type === STATE_MAP_KEY) {\r\n          if (!isValidMapKeyType(object)) {\r\n            throw new DecodeError(\"The type of key must be string or number but \" + typeof object);\r\n          }\r\n          if (object === \"__proto__\") {\r\n            throw new DecodeError(\"The key __proto__ is not allowed\");\r\n          }\r\n\r\n          state.key = object;\r\n          state.type = STATE_MAP_VALUE;\r\n          continue DECODE;\r\n        } else {\r\n          // it must be `state.type === State.MAP_VALUE` here\r\n\r\n          state.map[state.key!] = object;\r\n          state.readCount++;\r\n\r\n          if (state.readCount === state.size) {\r\n            object = state.map;\r\n            stack.release(state);\r\n          } else {\r\n            state.key = null;\r\n            state.type = STATE_MAP_KEY;\r\n            continue DECODE;\r\n          }\r\n        }\r\n      }\r\n\r\n      return object;\r\n    }\r\n  }\r\n\r\n  private readHeadByte(): number {\r\n    if (this.headByte === HEAD_BYTE_REQUIRED) {\r\n      this.headByte = this.readU8();\r\n      // console.log(\"headByte\", prettyByte(this.headByte));\r\n    }\r\n\r\n    return this.headByte;\r\n  }\r\n\r\n  private complete(): void {\r\n    this.headByte = HEAD_BYTE_REQUIRED;\r\n  }\r\n\r\n  private readArraySize(): number {\r\n    const headByte = this.readHeadByte();\r\n\r\n    switch (headByte) {\r\n      case 0xdc:\r\n        return this.readU16();\r\n      case 0xdd:\r\n        return this.readU32();\r\n      default: {\r\n        if (headByte < 0xa0) {\r\n          return headByte - 0x90;\r\n        } else {\r\n          throw new DecodeError(`Unrecognized array type byte: ${prettyByte(headByte)}`);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private pushMapState(size: number) {\r\n    if (size > this.maxMapLength) {\r\n      throw new DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);\r\n    }\r\n\r\n    this.stack.pushMapState(size);\r\n  }\r\n\r\n  private pushArrayState(size: number) {\r\n    if (size > this.maxArrayLength) {\r\n      throw new DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);\r\n    }\r\n\r\n    this.stack.pushArrayState(size);\r\n  }\r\n\r\n  private decodeUtf8String(byteLength: number, headerOffset: number): string {\r\n    if (byteLength > this.maxStrLength) {\r\n      throw new DecodeError(\r\n        `Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`,\r\n      );\r\n    }\r\n\r\n    if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\r\n      throw MORE_DATA;\r\n    }\r\n\r\n    const offset = this.pos + headerOffset;\r\n    let object: string;\r\n    if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength)) {\r\n      object = this.keyDecoder.decode(this.bytes, offset, byteLength);\r\n    } else {\r\n      object = utf8Decode(this.bytes, offset, byteLength);\r\n    }\r\n    this.pos += headerOffset + byteLength;\r\n    return object;\r\n  }\r\n\r\n  private stateIsMapKey(): boolean {\r\n    if (this.stack.length > 0) {\r\n      const state = this.stack.top()!;\r\n      return state.type === STATE_MAP_KEY;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private decodeBinary(byteLength: number, headOffset: number): Uint8Array {\r\n    if (byteLength > this.maxBinLength) {\r\n      throw new DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);\r\n    }\r\n\r\n    if (!this.hasRemaining(byteLength + headOffset)) {\r\n      throw MORE_DATA;\r\n    }\r\n\r\n    const offset = this.pos + headOffset;\r\n    const object = this.bytes.subarray(offset, offset + byteLength);\r\n    this.pos += headOffset + byteLength;\r\n    return object;\r\n  }\r\n\r\n  private decodeExtension(size: number, headOffset: number): unknown {\r\n    if (size > this.maxExtLength) {\r\n      throw new DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);\r\n    }\r\n\r\n    const extType = this.view.getInt8(this.pos + headOffset);\r\n    const data = this.decodeBinary(size, headOffset + 1 /* extType */);\r\n    return this.extensionCodec.decode(data, extType, this.context);\r\n  }\r\n\r\n  private lookU8() {\r\n    return this.view.getUint8(this.pos);\r\n  }\r\n\r\n  private lookU16() {\r\n    return this.view.getUint16(this.pos);\r\n  }\r\n\r\n  private lookU32() {\r\n    return this.view.getUint32(this.pos);\r\n  }\r\n\r\n  private readU8(): number {\r\n    const value = this.view.getUint8(this.pos);\r\n    this.pos++;\r\n    return value;\r\n  }\r\n\r\n  private readI8(): number {\r\n    const value = this.view.getInt8(this.pos);\r\n    this.pos++;\r\n    return value;\r\n  }\r\n\r\n  private readU16(): number {\r\n    const value = this.view.getUint16(this.pos);\r\n    this.pos += 2;\r\n    return value;\r\n  }\r\n\r\n  private readI16(): number {\r\n    const value = this.view.getInt16(this.pos);\r\n    this.pos += 2;\r\n    return value;\r\n  }\r\n\r\n  private readU32(): number {\r\n    const value = this.view.getUint32(this.pos);\r\n    this.pos += 4;\r\n    return value;\r\n  }\r\n\r\n  private readI32(): number {\r\n    const value = this.view.getInt32(this.pos);\r\n    this.pos += 4;\r\n    return value;\r\n  }\r\n\r\n  private readU64(): number {\r\n    const value = getUint64(this.view, this.pos);\r\n    this.pos += 8;\r\n    return value;\r\n  }\r\n\r\n  private readI64(): number {\r\n    const value = getInt64(this.view, this.pos);\r\n    this.pos += 8;\r\n    return value;\r\n  }\r\n\r\n  private readU64AsBigInt(): bigint {\r\n    const value = this.view.getBigUint64(this.pos);\r\n    this.pos += 8;\r\n    return value;\r\n  }\r\n\r\n  private readI64AsBigInt(): bigint {\r\n    const value = this.view.getBigInt64(this.pos);\r\n    this.pos += 8;\r\n    return value;\r\n  }\r\n\r\n  private readF32() {\r\n    const value = this.view.getFloat32(this.pos);\r\n    this.pos += 4;\r\n    return value;\r\n  }\r\n\r\n  private readF64() {\r\n    const value = this.view.getFloat64(this.pos);\r\n    this.pos += 8;\r\n    return value;\r\n  }\r\n}\r\n","import { utf8DecodeJs } from \"./utils/utf8\";\r\n\r\nconst DEFAULT_MAX_KEY_LENGTH = 16;\r\nconst DEFAULT_MAX_LENGTH_PER_KEY = 16;\r\n\r\nexport interface KeyDecoder {\r\n  canBeCached(byteLength: number): boolean;\r\n  decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string;\r\n}\r\ninterface KeyCacheRecord {\r\n  readonly bytes: Uint8Array;\r\n  readonly str: string;\r\n}\r\n\r\nexport class CachedKeyDecoder implements KeyDecoder {\r\n  hit = 0;\r\n  miss = 0;\r\n  private readonly caches: Array<Array<KeyCacheRecord>>;\r\n\r\n  constructor(\r\n    readonly maxKeyLength = DEFAULT_MAX_KEY_LENGTH,\r\n    readonly maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY,\r\n  ) {\r\n    // avoid `new Array(N)`, which makes a sparse array,\r\n    // because a sparse array is typically slower than a non-sparse array.\r\n    this.caches = [];\r\n    for (let i = 0; i < this.maxKeyLength; i++) {\r\n      this.caches.push([]);\r\n    }\r\n  }\r\n\r\n  public canBeCached(byteLength: number): boolean {\r\n    return byteLength > 0 && byteLength <= this.maxKeyLength;\r\n  }\r\n\r\n  private find(bytes: Uint8Array, inputOffset: number, byteLength: number): string | null {\r\n    const records = this.caches[byteLength - 1]!;\r\n\r\n    FIND_CHUNK: for (const record of records) {\r\n      const recordBytes = record.bytes;\r\n\r\n      for (let j = 0; j < byteLength; j++) {\r\n        if (recordBytes[j] !== bytes[inputOffset + j]) {\r\n          continue FIND_CHUNK;\r\n        }\r\n      }\r\n      return record.str;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private store(bytes: Uint8Array, value: string) {\r\n    const records = this.caches[bytes.length - 1]!;\r\n    const record: KeyCacheRecord = { bytes, str: value };\r\n\r\n    if (records.length >= this.maxLengthPerKey) {\r\n      // `records` are full!\r\n      // Set `record` to an arbitrary position.\r\n      records[(Math.random() * records.length) | 0] = record;\r\n    } else {\r\n      records.push(record);\r\n    }\r\n  }\r\n\r\n  public decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\r\n    const cachedValue = this.find(bytes, inputOffset, byteLength);\r\n    if (cachedValue != null) {\r\n      this.hit++;\r\n      return cachedValue;\r\n    }\r\n    this.miss++;\r\n\r\n    const str = utf8DecodeJs(bytes, inputOffset, byteLength);\r\n    // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\r\n    const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\r\n    this.store(slicedCopyOfBytes, str);\r\n    return str;\r\n  }\r\n}\r\n","import { Decoder } from \"./Decoder\";\r\nimport type { DecoderOptions } from \"./Decoder\";\r\nimport type { SplitUndefined } from \"./context\";\r\n\r\n/**\r\n * @deprecated Use {@link DecoderOptions} instead.\r\n */\r\nexport type DecodeOptions = never;\r\n\r\n/**\r\n * @deprecated No longer supported.\r\n */\r\nexport const defaultDecodeOptions: never = undefined as never;\r\n\r\n/**\r\n * It decodes a single MessagePack object in a buffer.\r\n *\r\n * This is a synchronous decoding function.\r\n * See other variants for asynchronous decoding: {@link decodeAsync}, {@link decodeStream}, or {@link decodeArrayStream}.\r\n *\r\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\r\n * @throws {@link DecodeError} if the buffer contains invalid data.\r\n */\r\nexport function decode<ContextType = undefined>(\r\n  buffer: ArrayLike<number> | BufferSource,\r\n  options?: DecoderOptions<SplitUndefined<ContextType>>,\r\n): unknown {\r\n  const decoder = new Decoder(options);\r\n  return decoder.decode(buffer);\r\n}\r\n\r\n/**\r\n * It decodes multiple MessagePack objects in a buffer.\r\n * This is corresponding to {@link decodeMultiStream}.\r\n *\r\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\r\n * @throws {@link DecodeError} if the buffer contains invalid data.\r\n */\r\nexport function decodeMulti<ContextType = undefined>(\r\n  buffer: ArrayLike<number> | BufferSource,\r\n  options?: DecoderOptions<SplitUndefined<ContextType>>,\r\n): Generator<unknown, void, unknown> {\r\n  const decoder = new Decoder(options);\r\n  return decoder.decodeMulti(buffer);\r\n}\r\n","// utility for whatwg streams\r\n\r\n// The living standard of whatwg streams says\r\n// ReadableStream is also AsyncIterable, but\r\n// as of June 2019, no browser implements it.\r\n// See https://streams.spec.whatwg.org/ for details\r\nexport type ReadableStreamLike<T> = AsyncIterable<T> | ReadableStream<T>;\r\n\r\nexport function isAsyncIterable<T>(object: ReadableStreamLike<T>): object is AsyncIterable<T> {\r\n  return (object as any)[Symbol.asyncIterator] != null;\r\n}\r\n\r\nfunction assertNonNull<T>(value: T | null | undefined): asserts value is T {\r\n  if (value == null) {\r\n    throw new Error(\"Assertion Failure: value must not be null nor undefined\");\r\n  }\r\n}\r\n\r\nexport async function* asyncIterableFromStream<T>(stream: ReadableStream<T>): AsyncIterable<T> {\r\n  const reader = stream.getReader();\r\n\r\n  try {\r\n    while (true) {\r\n      const { done, value } = await reader.read();\r\n      if (done) {\r\n        return;\r\n      }\r\n      assertNonNull(value);\r\n      yield value;\r\n    }\r\n  } finally {\r\n    reader.releaseLock();\r\n  }\r\n}\r\n\r\nexport function ensureAsyncIterable<T>(streamLike: ReadableStreamLike<T>): AsyncIterable<T> {\r\n  if (isAsyncIterable(streamLike)) {\r\n    return streamLike;\r\n  } else {\r\n    return asyncIterableFromStream(streamLike);\r\n  }\r\n}\r\n","import { Decoder } from \"./Decoder\";\r\nimport { ensureAsyncIterable } from \"./utils/stream\";\r\nimport type { DecoderOptions } from \"./Decoder\";\r\nimport type { ReadableStreamLike } from \"./utils/stream\";\r\nimport type { SplitUndefined } from \"./context\";\r\n\r\n/**\r\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\r\n * @throws {@link DecodeError} if the buffer contains invalid data.\r\n */\r\nexport async function decodeAsync<ContextType = undefined>(\r\n  streamLike: ReadableStreamLike<ArrayLike<number> | BufferSource>,\r\n  options?: DecoderOptions<SplitUndefined<ContextType>>,\r\n): Promise<unknown> {\r\n  const stream = ensureAsyncIterable(streamLike);\r\n  const decoder = new Decoder(options);\r\n  return decoder.decodeAsync(stream);\r\n}\r\n\r\n/**\r\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\r\n * @throws {@link DecodeError} if the buffer contains invalid data.\r\n */\r\nexport function decodeArrayStream<ContextType>(\r\n  streamLike: ReadableStreamLike<ArrayLike<number> | BufferSource>,\r\n  options?: DecoderOptions<SplitUndefined<ContextType>>,\r\n): AsyncGenerator<unknown, void, unknown> {\r\n  const stream = ensureAsyncIterable(streamLike);\r\n  const decoder = new Decoder(options);\r\n  return decoder.decodeArrayStream(stream);\r\n}\r\n\r\n/**\r\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\r\n * @throws {@link DecodeError} if the buffer contains invalid data.\r\n */\r\nexport function decodeMultiStream<ContextType>(\r\n  streamLike: ReadableStreamLike<ArrayLike<number> | BufferSource>,\r\n  options?: DecoderOptions<SplitUndefined<ContextType>>,\r\n): AsyncGenerator<unknown, void, unknown> {\r\n  const stream = ensureAsyncIterable(streamLike);\r\n  const decoder = new Decoder(options);\r\n  return decoder.decodeStream(stream);\r\n}\r\n\r\n/**\r\n * @deprecated Use {@link decodeMultiStream} instead.\r\n */\r\nexport const decodeStream: never = undefined as never;\r\n"],"names":["sharedTextEncoder","TextEncoder","utf8Encode","str","output","outputOffset","length","encodeInto","subarray","utf8EncodeTE","strLength","offset","pos","value","charCodeAt","extra","utf8EncodeJs","CHUNK_SIZE","utf8DecodeJs","bytes","inputOffset","byteLength","end","units","result","byte1","byte2","push","byte3","unit","String","fromCharCode","sharedTextDecoder","TextDecoder","utf8Decode","stringBytes","decode","utf8DecodeTD","ExtData","constructor","type","data","this","DecodeError","Error","message","super","proto","Object","create","prototype","setPrototypeOf","defineProperty","configurable","enumerable","name","UINT32_MAX","setInt64","view","high","Math","floor","low","setUint32","getInt64","getInt32","getUint32","EXT_TIMESTAMP","TIMESTAMP32_MAX_SEC","TIMESTAMP64_MAX_SEC","encodeTimeSpecToTimestamp","sec","nsec","rv","Uint8Array","DataView","buffer","secHigh","secLow","encodeDateToTimeSpec","date","msec","getTime","nsecInSec","encodeTimestampExtension","object","Date","decodeTimestampToTimeSpec","byteOffset","nsec30AndSecHigh2","decodeTimestampExtension","timeSpec","timestampExtension","encode","ExtensionCodec","builtInEncoders","builtInDecoders","encoders","decoders","register","index","tryToEncode","context","i","encodeExt","decodeExt","ensureUint8Array","ArrayBuffer","isView","from","defaultCodec","Encoder","options","extensionCodec","useBigInt64","maxDepth","initialBufferSize","sortKeys","forceFloat32","ignoreUndefined","forceIntegerToFloat","reinitializeState","encodeSharedRef","doEncode","slice","depth","encodeNil","encodeBoolean","encodeNumberAsFloat","encodeNumber","encodeString","encodeBigInt64","encodeObject","ensureBufferSizeToWrite","sizeToWrite","requiredSize","resizeBuffer","newSize","newBuffer","newBytes","newView","set","writeU8","Number","isSafeInteger","writeU16","writeU32","writeU64","writeI8","writeI16","writeI32","writeI64","writeF32","writeF64","BigInt","writeBigUint64","writeBigInt64","writeStringHeader","utf8Count","ext","encodeExtension","Array","isArray","encodeArray","encodeBinary","toString","apply","encodeMap","size","writeU8a","item","countWithoutUndefined","keys","count","key","undefined","sort","setUint8","values","setInt8","setUint16","setInt16","setInt32","setFloat32","setFloat64","setUint64","setBigUint64","setBigInt64","prettyByte","byte","abs","padStart","STATE_ARRAY","STATE_MAP_KEY","STATE_MAP_VALUE","StackPool","stack","stackHeadPosition","top","pushArrayState","state","getUninitializedStateFromPool","position","array","pushMapState","readCount","map","partialState","release","reset","EMPTY_VIEW","EMPTY_BYTES","getInt8","e","RangeError","DataViewIndexOutOfBoundsError","MORE_DATA","sharedCachedKeyDecoder","maxKeyLength","maxLengthPerKey","hit","miss","caches","canBeCached","find","records","FIND_CHUNK","record","recordBytes","j","store","random","cachedValue","slicedCopyOfBytes","call","Decoder","totalPos","headByte","maxStrLength","maxBinLength","maxArrayLength","maxMapLength","maxExtLength","keyDecoder","setBuffer","bufferView","createDataView","appendBuffer","hasRemaining","remainingData","newData","createExtraByteError","posToShow","doDecodeSync","decodeMulti","decodeAsync","stream","decoded","decodeArrayStream","decodeMultiAsync","decodeStream","isArrayHeaderRequired","arrayItemsLeft","readArraySize","complete","DECODE","readHeadByte","decodeUtf8String","readF32","readF64","readU8","readU16","readU32","readU64AsBigInt","readU64","readI8","readI16","readI32","readI64AsBigInt","readI64","lookU8","lookU16","lookU32","decodeBinary","decodeExtension","headerOffset","stateIsMapKey","headOffset","extType","getUint8","getUint16","getInt16","getBigUint64","getBigInt64","getFloat32","getFloat64","assertNonNull","ensureAsyncIterable","streamLike","Symbol","asyncIterator","async","reader","getReader","done","read","releaseLock","asyncIterableFromStream","decodeMultiStream"],"mappings":"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"}