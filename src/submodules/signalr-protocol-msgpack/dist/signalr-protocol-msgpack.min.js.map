{"version":3,"file":"signalr-protocol-msgpack.min.js","sources":["../../src/pkg-version.ts","../../src/BinaryMessageFormat.ts","../../src/MessagePackHubProtocol.ts","../../src/Utils.ts"],"sourcesContent":["export const VERSION = '5.0.0-dev';","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\n// Not exported from index.\r\n/** @private */\r\nexport class BinaryMessageFormat {\r\n\r\n    // The length prefix of binary messages is encoded as VarInt. Read the comment in\r\n    // the BinaryMessageParser.TryParseMessage for details.\r\n\r\n    public static write(output: Uint8Array): ArrayBuffer {\r\n        let size = output.byteLength || output.length;\r\n        const lenBuffer = [];\r\n        do {\r\n            let sizePart = size & 0x7f;\r\n            size = size >> 7;\r\n            if (size > 0) {\r\n                sizePart |= 0x80;\r\n            }\r\n            lenBuffer.push(sizePart);\r\n        }\r\n        while (size > 0);\r\n\r\n        size = output.byteLength || output.length;\r\n\r\n        const buffer = new Uint8Array(lenBuffer.length + size);\r\n        buffer.set(lenBuffer, 0);\r\n        buffer.set(output, lenBuffer.length);\r\n        return buffer.buffer;\r\n    }\r\n\r\n    public static parse(input: ArrayBuffer): Uint8Array[] {\r\n        const result: Uint8Array[] = [];\r\n        const uint8Array = new Uint8Array(input);\r\n        const maxLengthPrefixSize = 5;\r\n        const numBitsToShift = [0, 7, 14, 21, 28 ];\r\n\r\n        for (let offset = 0; offset < input.byteLength;) {\r\n            let numBytes = 0;\r\n            let size = 0;\r\n            let byteRead;\r\n            do {\r\n                byteRead = uint8Array[offset + numBytes];\r\n                size = size | ((byteRead & 0x7f) << (numBitsToShift[numBytes]));\r\n                numBytes++;\r\n            }\r\n            while (numBytes < Math.min(maxLengthPrefixSize, input.byteLength - offset) && (byteRead & 0x80) !== 0);\r\n\r\n            if ((byteRead & 0x80) !== 0 && numBytes < maxLengthPrefixSize) {\r\n                throw new Error(\"Cannot read message size.\");\r\n            }\r\n\r\n            if (numBytes === maxLengthPrefixSize && byteRead > 7) {\r\n                throw new Error(\"Messages bigger than 2GB are not supported.\");\r\n            }\r\n\r\n            if (uint8Array.byteLength >= (offset + numBytes + size)) {\r\n                // IE does not support .slice() so use subarray\r\n                result.push(uint8Array.slice\r\n                    ? uint8Array.slice(offset + numBytes, offset + numBytes + size)\r\n                    : uint8Array.subarray(offset + numBytes, offset + numBytes + size));\r\n            } else {\r\n                throw new Error(\"Incomplete message.\");\r\n            }\r\n\r\n            offset = offset + numBytes + size;\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { Encoder, Decoder } from \"@msgpack/msgpack\";\r\n\r\nimport { MessagePackOptions } from \"./MessagePackOptions\";\r\n\r\nimport {\r\n    AckMessage,\r\n    CancelInvocationMessage, CompletionMessage, HubMessage, IHubProtocol, ILogger, InvocationMessage,\r\n    LogLevel, MessageHeaders, MessageType, NullLogger, SequenceMessage, StreamInvocationMessage, StreamItemMessage, TransferFormat,\r\n} from \"@microsoft/signalr\";\r\n\r\nimport { BinaryMessageFormat } from \"./BinaryMessageFormat\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\n\r\n// TypeDoc's @inheritDoc and @link don't work across modules :(\r\n\r\n// constant encoding of the ping message\r\n// see: https://github.com/aspnet/SignalR/blob/dev/specs/HubProtocol.md#ping-message-encoding-1\r\n// Don't use Uint8Array.from as IE does not support it\r\nconst SERIALIZED_PING_MESSAGE: Uint8Array = new Uint8Array([0x91, MessageType.Ping]);\r\n\r\n/** Implements the MessagePack Hub Protocol */\r\nexport class MessagePackHubProtocol implements IHubProtocol {\r\n    /** The name of the protocol. This is used by SignalR to resolve the protocol between the client and server. */\r\n    public readonly name: string = \"messagepack\";\r\n    /** The version of the protocol. */\r\n    public readonly version: number = 2;\r\n    /** The TransferFormat of the protocol. */\r\n    public readonly transferFormat: TransferFormat = TransferFormat.Binary;\r\n\r\n    private readonly _errorResult = 1;\r\n    private readonly _voidResult = 2;\r\n    private readonly _nonVoidResult = 3;\r\n\r\n    private readonly _encoder: Encoder<undefined>;\r\n    private readonly _decoder: Decoder<undefined>;\r\n\r\n    /**\r\n     *\r\n     * @param messagePackOptions MessagePack options passed to @msgpack/msgpack\r\n     */\r\n    constructor(messagePackOptions?: MessagePackOptions) {\r\n        messagePackOptions = messagePackOptions || {};\r\n        this._encoder = new Encoder(\r\n            messagePackOptions.extensionCodec,\r\n            messagePackOptions.context,\r\n            messagePackOptions.maxDepth,\r\n            messagePackOptions.initialBufferSize,\r\n            messagePackOptions.sortKeys,\r\n            messagePackOptions.forceFloat32,\r\n            messagePackOptions.ignoreUndefined,\r\n            messagePackOptions.forceIntegerToFloat,\r\n        );\r\n\r\n        this._decoder = new Decoder(\r\n            messagePackOptions.extensionCodec,\r\n            messagePackOptions.context,\r\n            messagePackOptions.maxStrLength,\r\n            messagePackOptions.maxBinLength,\r\n            messagePackOptions.maxArrayLength,\r\n            messagePackOptions.maxMapLength,\r\n            messagePackOptions.maxExtLength,\r\n        );\r\n    }\r\n\r\n    /** Creates an array of HubMessage objects from the specified serialized representation.\r\n     *\r\n     * @param {ArrayBuffer} input An ArrayBuffer containing the serialized representation.\r\n     * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\r\n     */\r\n    public parseMessages(input: ArrayBuffer, logger: ILogger): HubMessage[] {\r\n        // The interface does allow \"string\" to be passed in, but this implementation does not. So let's throw a useful error.\r\n        if (!(isArrayBuffer(input))) {\r\n            throw new Error(\"Invalid input for MessagePack hub protocol. Expected an ArrayBuffer.\");\r\n        }\r\n\r\n        if (logger === null) {\r\n            logger = NullLogger.instance;\r\n        }\r\n\r\n        const messages = BinaryMessageFormat.parse(input);\r\n\r\n        const hubMessages = [];\r\n        for (const message of messages) {\r\n            const parsedMessage = this._parseMessage(message, logger);\r\n            // Can be null for an unknown message. Unknown message is logged in parseMessage\r\n            if (parsedMessage) {\r\n                hubMessages.push(parsedMessage);\r\n            }\r\n        }\r\n\r\n        return hubMessages;\r\n    }\r\n\r\n    /** Writes the specified HubMessage to an ArrayBuffer and returns it.\r\n     *\r\n     * @param {HubMessage} message The message to write.\r\n     * @returns {ArrayBuffer} An ArrayBuffer containing the serialized representation of the message.\r\n     */\r\n    public writeMessage(message: HubMessage): ArrayBuffer {\r\n        switch (message.type) {\r\n            case MessageType.Invocation:\r\n                return this._writeInvocation(message as InvocationMessage);\r\n            case MessageType.StreamInvocation:\r\n                return this._writeStreamInvocation(message as StreamInvocationMessage);\r\n            case MessageType.StreamItem:\r\n                return this._writeStreamItem(message as StreamItemMessage);\r\n            case MessageType.Completion:\r\n                return this._writeCompletion(message as CompletionMessage);\r\n            case MessageType.Ping:\r\n                return BinaryMessageFormat.write(SERIALIZED_PING_MESSAGE);\r\n            case MessageType.CancelInvocation:\r\n                return this._writeCancelInvocation(message as CancelInvocationMessage);\r\n            case MessageType.Close:\r\n                return this._writeClose();\r\n            case MessageType.Ack:\r\n                return this._writeAck(message as AckMessage);\r\n            case MessageType.Sequence:\r\n                return this._writeSequence(message as SequenceMessage);\r\n            default:\r\n                throw new Error(\"Invalid message type.\");\r\n        }\r\n    }\r\n\r\n    private _parseMessage(input: Uint8Array, logger: ILogger): HubMessage | null {\r\n        if (input.length === 0) {\r\n            throw new Error(\"Invalid payload.\");\r\n        }\r\n\r\n        const properties = this._decoder.decode(input) as any;\r\n        if (properties.length === 0 || !(properties instanceof Array)) {\r\n            throw new Error(\"Invalid payload.\");\r\n        }\r\n\r\n        const messageType = properties[0] as MessageType;\r\n\r\n        switch (messageType) {\r\n            case MessageType.Invocation:\r\n                return this._createInvocationMessage(this._readHeaders(properties), properties);\r\n            case MessageType.StreamItem:\r\n                return this._createStreamItemMessage(this._readHeaders(properties), properties);\r\n            case MessageType.Completion:\r\n                return this._createCompletionMessage(this._readHeaders(properties), properties);\r\n            case MessageType.Ping:\r\n                return this._createPingMessage(properties);\r\n            case MessageType.Close:\r\n                return this._createCloseMessage(properties);\r\n            case MessageType.Ack:\r\n                return this._createAckMessage(properties);\r\n            case MessageType.Sequence:\r\n                return this._createSequenceMessage(properties);\r\n            default:\r\n                // Future protocol changes can add message types, old clients can ignore them\r\n                logger.log(LogLevel.Information, \"Unknown message type '\" + messageType + \"' ignored.\");\r\n                return null;\r\n        }\r\n    }\r\n\r\n    private _createCloseMessage(properties: any[]): HubMessage {\r\n        // check minimum length to allow protocol to add items to the end of objects in future releases\r\n        if (properties.length < 2) {\r\n            throw new Error(\"Invalid payload for Close message.\");\r\n        }\r\n\r\n        return {\r\n            // Close messages have no headers.\r\n            allowReconnect: properties.length >= 3 ? properties[2] : undefined,\r\n            error: properties[1],\r\n            type: MessageType.Close,\r\n        } as HubMessage;\r\n    }\r\n\r\n    private _createPingMessage(properties: any[]): HubMessage {\r\n        // check minimum length to allow protocol to add items to the end of objects in future releases\r\n        if (properties.length < 1) {\r\n            throw new Error(\"Invalid payload for Ping message.\");\r\n        }\r\n\r\n        return {\r\n            // Ping messages have no headers.\r\n            type: MessageType.Ping,\r\n        } as HubMessage;\r\n    }\r\n\r\n    private _createInvocationMessage(headers: MessageHeaders, properties: any[]): InvocationMessage {\r\n        // check minimum length to allow protocol to add items to the end of objects in future releases\r\n        if (properties.length < 5) {\r\n            throw new Error(\"Invalid payload for Invocation message.\");\r\n        }\r\n\r\n        const invocationId = properties[2] as string;\r\n        if (invocationId) {\r\n            return {\r\n                arguments: properties[4],\r\n                headers,\r\n                invocationId,\r\n                streamIds: [],\r\n                target: properties[3] as string,\r\n                type: MessageType.Invocation,\r\n            };\r\n        } else {\r\n            return {\r\n                arguments: properties[4],\r\n                headers,\r\n                streamIds: [],\r\n                target: properties[3],\r\n                type: MessageType.Invocation,\r\n            };\r\n        }\r\n\r\n    }\r\n\r\n    private _createStreamItemMessage(headers: MessageHeaders, properties: any[]): StreamItemMessage {\r\n        // check minimum length to allow protocol to add items to the end of objects in future releases\r\n        if (properties.length < 4) {\r\n            throw new Error(\"Invalid payload for StreamItem message.\");\r\n        }\r\n\r\n        return {\r\n            headers,\r\n            invocationId: properties[2],\r\n            item: properties[3],\r\n            type: MessageType.StreamItem,\r\n        } as StreamItemMessage;\r\n    }\r\n\r\n    private _createCompletionMessage(headers: MessageHeaders, properties: any[]): CompletionMessage {\r\n        // check minimum length to allow protocol to add items to the end of objects in future releases\r\n        if (properties.length < 4) {\r\n            throw new Error(\"Invalid payload for Completion message.\");\r\n        }\r\n\r\n        const resultKind = properties[3];\r\n\r\n        if (resultKind !== this._voidResult && properties.length < 5) {\r\n            throw new Error(\"Invalid payload for Completion message.\");\r\n        }\r\n\r\n        let error: string | undefined;\r\n        let result: any;\r\n\r\n        switch (resultKind) {\r\n            case this._errorResult:\r\n                error = properties[4];\r\n                break;\r\n            case this._nonVoidResult:\r\n                result = properties[4];\r\n                break;\r\n        }\r\n\r\n        const completionMessage: CompletionMessage = {\r\n            error,\r\n            headers,\r\n            invocationId: properties[2],\r\n            result,\r\n            type: MessageType.Completion,\r\n        };\r\n\r\n        return completionMessage;\r\n    }\r\n\r\n    private _createAckMessage(properties: any[]): HubMessage {\r\n        // check minimum length to allow protocol to add items to the end of objects in future releases\r\n        if (properties.length < 1) {\r\n            throw new Error(\"Invalid payload for Ack message.\");\r\n        }\r\n\r\n        return {\r\n            sequenceId: properties[1],\r\n            type: MessageType.Ack,\r\n        } as HubMessage;\r\n    }\r\n\r\n    private _createSequenceMessage(properties: any[]): HubMessage {\r\n        // check minimum length to allow protocol to add items to the end of objects in future releases\r\n        if (properties.length < 1) {\r\n            throw new Error(\"Invalid payload for Sequence message.\");\r\n        }\r\n\r\n        return {\r\n            sequenceId: properties[1],\r\n            type: MessageType.Sequence,\r\n        } as HubMessage;\r\n    }\r\n\r\n    private _writeInvocation(invocationMessage: InvocationMessage): ArrayBuffer {\r\n        let payload: any;\r\n        if (invocationMessage.streamIds) {\r\n            payload = this._encoder.encode([MessageType.Invocation, invocationMessage.headers || {}, invocationMessage.invocationId || null,\r\n            invocationMessage.target, invocationMessage.arguments, invocationMessage.streamIds]);\r\n        } else {\r\n            payload = this._encoder.encode([MessageType.Invocation, invocationMessage.headers || {}, invocationMessage.invocationId || null,\r\n            invocationMessage.target, invocationMessage.arguments]);\r\n        }\r\n\r\n        return BinaryMessageFormat.write(payload.slice());\r\n    }\r\n\r\n    private _writeStreamInvocation(streamInvocationMessage: StreamInvocationMessage): ArrayBuffer {\r\n        let payload: any;\r\n        if (streamInvocationMessage.streamIds) {\r\n            payload = this._encoder.encode([MessageType.StreamInvocation, streamInvocationMessage.headers || {}, streamInvocationMessage.invocationId,\r\n            streamInvocationMessage.target, streamInvocationMessage.arguments, streamInvocationMessage.streamIds]);\r\n        } else {\r\n            payload = this._encoder.encode([MessageType.StreamInvocation, streamInvocationMessage.headers || {}, streamInvocationMessage.invocationId,\r\n            streamInvocationMessage.target, streamInvocationMessage.arguments]);\r\n        }\r\n\r\n        return BinaryMessageFormat.write(payload.slice());\r\n    }\r\n\r\n    private _writeStreamItem(streamItemMessage: StreamItemMessage): ArrayBuffer {\r\n        const payload = this._encoder.encode([MessageType.StreamItem, streamItemMessage.headers || {}, streamItemMessage.invocationId,\r\n        streamItemMessage.item]);\r\n\r\n        return BinaryMessageFormat.write(payload.slice());\r\n    }\r\n\r\n    private _writeCompletion(completionMessage: CompletionMessage): ArrayBuffer {\r\n        const resultKind = completionMessage.error ? this._errorResult :\r\n            (completionMessage.result !== undefined) ? this._nonVoidResult : this._voidResult;\r\n\r\n        let payload: any;\r\n        switch (resultKind) {\r\n            case this._errorResult:\r\n                payload = this._encoder.encode([MessageType.Completion, completionMessage.headers || {}, completionMessage.invocationId, resultKind, completionMessage.error]);\r\n                break;\r\n            case this._voidResult:\r\n                payload = this._encoder.encode([MessageType.Completion, completionMessage.headers || {}, completionMessage.invocationId, resultKind]);\r\n                break;\r\n            case this._nonVoidResult:\r\n                payload = this._encoder.encode([MessageType.Completion, completionMessage.headers || {}, completionMessage.invocationId, resultKind, completionMessage.result]);\r\n                break;\r\n        }\r\n\r\n        return BinaryMessageFormat.write(payload.slice());\r\n    }\r\n\r\n    private _writeCancelInvocation(cancelInvocationMessage: CancelInvocationMessage): ArrayBuffer {\r\n        const payload = this._encoder.encode([MessageType.CancelInvocation, cancelInvocationMessage.headers || {}, cancelInvocationMessage.invocationId]);\r\n\r\n        return BinaryMessageFormat.write(payload.slice());\r\n    }\r\n\r\n    private _writeClose(): ArrayBuffer {\r\n        const payload = this._encoder.encode([MessageType.Close, null]);\r\n\r\n        return BinaryMessageFormat.write(payload.slice());\r\n    }\r\n\r\n    private _writeAck(ackMessage: AckMessage): ArrayBuffer {\r\n        const payload = this._encoder.encode([MessageType.Ack, ackMessage.sequenceId]);\r\n\r\n        return BinaryMessageFormat.write(payload.slice());\r\n    }\r\n\r\n    private _writeSequence(sequenceMessage: SequenceMessage): ArrayBuffer {\r\n        const payload = this._encoder.encode([MessageType.Sequence, sequenceMessage.sequenceId]);\r\n\r\n        return BinaryMessageFormat.write(payload.slice());\r\n    }\r\n\r\n    private _readHeaders(properties: any): MessageHeaders {\r\n        const headers: MessageHeaders = properties[1] as MessageHeaders;\r\n        if (typeof headers !== \"object\") {\r\n            throw new Error(\"Invalid headers.\");\r\n        }\r\n        return headers;\r\n    }\r\n}\r\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\n// Copied from signalr/Utils.ts\r\n/** @private */\r\nexport function isArrayBuffer(val: any): val is ArrayBuffer {\r\n    return val && typeof ArrayBuffer !== \"undefined\" &&\r\n        (val instanceof ArrayBuffer ||\r\n        // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\r\n        (val.constructor && val.constructor.name === \"ArrayBuffer\"));\r\n}\r\n"],"names":["VERSION","BinaryMessageFormat","write","output","size","byteLength","length","lenBuffer","sizePart","push","buffer","Uint8Array","set","parse","input","result","uint8Array","numBitsToShift","offset","byteRead","numBytes","Math","min","Error","slice","subarray","SERIALIZED_PING_MESSAGE","MessageType","Ping","MessagePackHubProtocol","constructor","messagePackOptions","this","name","version","transferFormat","TransferFormat","Binary","_errorResult","_voidResult","_nonVoidResult","_encoder","Encoder","extensionCodec","context","maxDepth","initialBufferSize","sortKeys","forceFloat32","ignoreUndefined","forceIntegerToFloat","_decoder","Decoder","maxStrLength","maxBinLength","maxArrayLength","maxMapLength","maxExtLength","parseMessages","logger","val","ArrayBuffer","NullLogger","instance","messages","hubMessages","message","parsedMessage","_parseMessage","writeMessage","type","Invocation","_writeInvocation","StreamInvocation","_writeStreamInvocation","StreamItem","_writeStreamItem","Completion","_writeCompletion","CancelInvocation","_writeCancelInvocation","Close","_writeClose","Ack","_writeAck","Sequence","_writeSequence","properties","decode","Array","messageType","_createInvocationMessage","_readHeaders","_createStreamItemMessage","_createCompletionMessage","_createPingMessage","_createCloseMessage","_createAckMessage","_createSequenceMessage","log","LogLevel","Information","allowReconnect","undefined","error","headers","invocationId","arguments","streamIds","target","item","resultKind","sequenceId","invocationMessage","payload","encode","streamInvocationMessage","streamItemMessage","completionMessage","cancelInvocationMessage","ackMessage","sequenceMessage"],"mappings":"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"}